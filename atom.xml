<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RadiomM的博客世界</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-13T12:28:49.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RadiomM</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>建议改成：this的全面解析(二)</title>
    <link href="http://yoursite.com/2020/03/13/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2020/03/13/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%BA%8C)/</id>
    <published>2020-03-13T12:28:49.000Z</published>
    <updated>2020-03-13T12:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>article p{    font-size:16px;    line-height:28px;}</style><p>大家好！许久不见甚是想念，仅仅过了两天不到，我又开始给你们写技(cai)术(ji)文章了。<br>上回说到，这this的指向，以及作用域的问题，其实我后来发现这个两个说的好像都差不多，但是呢，过于懒得我就不想改了。<br>所以今天，我就立马给大家介绍this的绑定规则！！！是不是好高兴，好激动，甚至有点想打赏我了。好的，我自恋了，下面直接开始。</p><a id="more"></a><p><img src="./jienigui.jpg" alt="杰尼龟-冲冲冲"></p><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>虽然我上篇文章粗略的说过，理解this的绑定，需要知道函数的调用位置，才能确认this绑定的对象。<br>下面是《你不知道的JavaScript上》中的一个例子：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//当前调用栈是：baz</span>    <span class="comment">//因此，当前调用位置是全局作用域</span>    <span class="built_in">console</span>.log(<span class="string">'baz'</span>);    bar(); <span class="comment">//&lt;-- bar的调用位置</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//当前调用栈是：baz -&gt; bar</span>    <span class="comment">//因此，当前调用位置是在baz中</span>    <span class="built_in">console</span>.log(<span class="string">'bar'</span>);    foo(); <span class="comment">//&lt;-- foo的调用位置</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//当前调用栈是：baz -&gt; bar -&gt; foo</span>    <span class="comment">//因此，当前调用位置是在bar中</span>    <span class="built_in">console</span>.log(<span class="string">'foo'</span>);&#125;baz()； <span class="comment">// &lt;-- baz的调用位置</span></code></pre><p>学习JS的同学，多少听过栈跟堆，当然这不是本文的重点，但是为了照顾同学，我决定以后出一篇（有机会的话，嘿嘿）。</p><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>接下来我们就会看看在函数的执行过程中调用位置如何决定this的绑定对象。<br>主要分为了四个规则，下面会逐一分析。</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则。</p><p>先来个简单的例子：</p><pre><code class="highlight javascript"><span class="keyword">var</span> a = <span class="number">2</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;foo() <span class="comment">// 2</span></code></pre><p>明显这个例子，就是算是初学者也会说的出答案。这其实就是默认绑定的一个最简单的例子，那么我们是怎么知道这里运用了默认绑定呢？可以通过分析调用位置来看看foo()是如何调用的。在代码中，foo()是直接使用不带任何修饰的函数引用进行的调用，因此只能使用默认绑定，无法使用其他规则。<br>但是如果是严格模式下(strict mode)的话,则不会绑定到全局对象中，因此this会绑定到undefined</p><pre><code class="highlight javascript"><span class="meta">'use strict'</span><span class="keyword">var</span> a = <span class="number">2</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;foo() <span class="comment">// TypeError: this is undefined</span></code></pre><p>但是在《你不知道的js的上》中提到了一个很微妙的例子，就是假如调用位置在严格模式(strict mode)下的话，则不会影响到默认绑定。</p><pre><code class="highlight javascript"><span class="keyword">var</span> a = <span class="number">2</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="meta">    'use strict'</span>     foo() <span class="comment">// 2</span>&#125;)()</code></pre><h3 id="秒杀默认绑定的技巧"><a href="#秒杀默认绑定的技巧" class="headerlink" title="秒杀默认绑定的技巧"></a>秒杀默认绑定的技巧</h3><p>对于初学者来说，就会问到：’有没有可以立马判断到这是默认绑定的技巧啊，我怕我脑子记太多不够用啊。’<br>既然你诚心诚意的问，我就大发慈悲的告诉你：’有！马上给你安排上’<br>在下面的三种场景下，this会100%指向window：</p><ul><li>立即执行函数（IIFE）</li><li>setTimeout 中传入的函数</li><li>setInterval 中传入的函数</li></ul><p>只要看到判断this的题，没必要第一步就去老实分析这个this绑定到那么对象上，而是应该先定位<strong>this 是否出现在了以上三种类型的函数里面</strong>。如果是，那么想也不想，直接去对应 window 就好了～</p><p>做题快感无非是秒杀嘛，不然为什么那么多人喜欢看<a href="https://baike.baidu.com/item/%E4%B8%80%E6%8B%B3%E8%B6%85%E4%BA%BA/1966105?fr=aladdin" target="_blank" rel="noopener">一拳超人</a></p><h4 id="立即执行函数（IIFE）、"><a href="#立即执行函数（IIFE）、" class="headerlink" title="立即执行函数（IIFE）、"></a>立即执行函数（IIFE）、</h4><p>所谓立即执行函数，就是定义后立刻调用的匿名函数（参见下面这道例题里 hello 方法的函数体里这种写法）。</p><pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">'RadiomM'</span><span class="keyword">var</span> me = &#123;  name: <span class="string">'ydw'</span>,  <span class="comment">// 声明位置</span>  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">`你好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)  &#125;,  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    (<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;      <span class="comment">// 调用位置</span>      cb()    &#125;)(<span class="keyword">this</span>.sayHello)  &#125;&#125;me.hello() <span class="comment">// 大家再猜下输出啥了？</span></code></pre><p>看到这里，我想你必须马上立刻给我喊出答案，那就是RaidomM。如果你不是立马想出答案的，我建议你再好好反省一下！！！！<br>好吧，你该反省完了，那么我接着说。</p><p>其实，即便不考虑立即执行的匿名函数这种所谓的“特殊情况”，大家按照我们上面的指向原则来分析，结果也是一样一样的。 立即执行函数作为一个匿名函数，在被调用的时候，我们往往就是直接调用，而不会（也无法）通过属性访问器（ 即 xx.xxx） 这样的形式来给它指定一个所在对象，所以它的 this 是非常确定的，就是默认的全局对象 window。</p><h4 id="setTimeout-和-setInterval-中传入的函数"><a href="#setTimeout-和-setInterval-中传入的函数" class="headerlink" title="setTimeout 和 setInterval 中传入的函数"></a>setTimeout 和 setInterval 中传入的函数</h4><p>众所周知，其实setTimeout和setInterval中的函数机制其实没什么区别，他们就是兄弟，既然是兄弟，那我就只拿一个兄弟setTimeout开刀了：</p><pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">'RadiomM'</span><span class="keyword">var</span> me = &#123;  name: <span class="string">'ydw'</span>,  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log(<span class="string">`你好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)    &#125;)  &#125;&#125;me.hello() <span class="comment">// 你好，我是RadiomM</span></code></pre><p>是不是觉得好神奇？我们的 this.name 明明看起来是在 me.hello () 里被调用的，结果却输出了 window.name。 setTimeout 到底对函数做了什么？</p><p>其实，我们所看到的延时效果（setTimeout）和定时效果（setInterval），都是在全局作用域下实现的。无论是 setTimeout 还是 setInterval 里传入的函数，都会首先被交付到全局对象手上。因此，函数中 this 的值，会被自动指向 window。</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3>]]></content>
    
    <summary type="html">
    
      &lt;style&gt;
article p{
    font-size:16px;
    line-height:28px;
}
&lt;/style&gt;

&lt;p&gt;大家好！许久不见甚是想念，仅仅过了两天不到，我又开始给你们写技(cai)术(ji)文章了。&lt;br&gt;上回说到，这this的指向，以及作用域的问题，其实我后来发现这个两个说的好像都差不多，但是呢，过于懒得我就不想改了。&lt;br&gt;所以今天，我就立马给大家介绍this的绑定规则！！！是不是好高兴，好激动，甚至有点想打赏我了。好的，我自恋了，下面直接开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>建议改成：this的全面解析(一)</title>
    <link href="http://yoursite.com/2020/03/12/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%B8%80)/"/>
    <id>http://yoursite.com/2020/03/12/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%B8%80)/</id>
    <published>2020-03-12T05:27:24.000Z</published>
    <updated>2020-03-12T05:27:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>article p{    font-size:16px;    line-height:28px;}</style><p>嗨，大家好！过了那么几天我又开始写文章了，这次给大家带来的是this的全面解析。会不会有人会问，怎么突然就这么高产了？其实是这样的，因为这次疫情的出现，让我原本的计划出现了变动，当然也让我认清了我小公司的老板是多么的抠门。所以接下来的文章，基本都是会写一些面试多次会考的问题。当然，作为前端工程师，那么我们的基本功除了HTML，CSS意外，最重要的就是这个JS中的this。废话说完，那么接下来我们就开始了。</p><a id="more"></a><h2 id="this是指向的是谁？"><a href="#this是指向的是谁？" class="headerlink" title="this是指向的是谁？"></a>this是指向的是谁？</h2><p>在多数的情况下，this指向的是调用方法的那个对象。<strong>简单的说就是谁调用函数，那么this就是指向这个对象。</strong><br> <pre><code class="highlight delphi"><span class="keyword">var</span> a = <span class="number">1</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span><span class="function"><span class="comment">    console.log(this.a)</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"><span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出 1</span></span><span class="function"></span><span class="function"><span class="title">let</span> <span class="title">obj</span> = <span class="comment">&#123;</span></span><span class="function"><span class="comment">    a: 2,</span></span><span class="function"><span class="comment">    foo:foo</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">obj</span>.<span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出2</span></span></code></pre></p><p>上面的代码对于老手来说应该没有什么问题。这里我对新手提点注意的点，那就是foo()的调用其实相当于window.foo()，又因为var定义的变量在<strong>非严格模式下</strong>会自动挂载到全局对象中，<strong>在浏览器中，指向 window；在 Node 中，指向 Global。（严格模式下，指向 undefined）</strong></p><h2 id="this的作用域指向哪里？"><a href="#this的作用域指向哪里？" class="headerlink" title="this的作用域指向哪里？"></a>this的作用域指向哪里？</h2><p>很多新手学习JavaScript的同学来说，都会认为this指向的是函数的作用域，实际上并不是这样的，实际上你看了上面的两个例子之后，<br>你就会发现，第一个符合，而第二个却是不符合的。再看下面一个经典的题目，你可能就有点意思了。（不懂作用域的同学，之后我也会出一篇的。）</p><pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">"zhangsan"</span>;<span class="keyword">var</span> obj = &#123;    name:<span class="string">"RadiomM"</span>,    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         <span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) &#125;;        x();    &#125;&#125;obj.fn() <span class="comment">// zhangsan</span></code></pre><p>是不是答案有点出乎了意料，这大多是因为觉得this指向函数作用域的关系，看x函数在obj对象的属性方法中定义，想当然的以为这时候调用函数x的就是这个obj对象，事实上这是大错特错的，有必要简单的说说，什么是声明，什么是调用。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>看下面的例子：</p><pre><code class="highlight cs"><span class="keyword">var</span> a = <span class="number">1</span><span class="function">funciton <span class="title">foo</span>(<span class="params"></span>)</span> &#123;    console.log(a)&#125;</code></pre><p>没错，就是这么简单，这就是声明函数foo。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>看下面的例子：</p><pre><code class="highlight stylus"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span>funciton foo() &#123;    console.log(a)&#125;<span class="comment">// 这就是调用</span><span class="function"><span class="title">foo</span><span class="params">()</span></span></code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>重要的事情说三遍，建议你大声跟着读下面的字：<br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br>实际上，你读完上面的字，你还是会疑惑，那么为什么输出的就是这个zhangsan呢？其实，我在第一个例子中<br>已经给了提示了，实际上这个x()就相当于window.x()，那么这道题就相当的明了了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>话不多说，直接抬总结上来：</p><p>1、this绑定实际上是在函数被调用时发生的绑定，它的指向取决于函数在哪里被调用。</p><p>2、this的作用域并不是指向函数的作用域。</p><p>其实这篇文章仅仅是入门this的基础，下一篇文章我将会全面解析this的绑定规则。<br>看到这里你可能会问什么会是下一篇呢？因为我写累了啊，哈哈。<br>给大兄弟来首歌轻松轻松。（这篇文章就是在快乐气氛下写完的。学习可别忘了快乐，hasaki！）</p>    <div id="aplayer-vREnYnAB" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="29732992" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>如果文章有错误的地方，希望小哥哥小姐姐们在评论区指出，毕竟作者的水平确实有限。</p>]]></content>
    
    <summary type="html">
    
      &lt;style&gt;
article p{
    font-size:16px;
    line-height:28px;
}
&lt;/style&gt;


&lt;p&gt;嗨，大家好！过了那么几天我又开始写文章了，这次给大家带来的是this的全面解析。会不会有人会问，怎么突然就这么高产了？其实是这样的，因为这次疫情的出现，让我原本的计划出现了变动，当然也让我认清了我小公司的老板是多么的抠门。所以接下来的文章，基本都是会写一些面试多次会考的问题。当然，作为前端工程师，那么我们的基本功除了HTML，CSS意外，最重要的就是这个JS中的this。废话说完，那么接下来我们就开始了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>手动实现一个v-model的不同做法</title>
    <link href="http://yoursite.com/2020/03/08/model/"/>
    <id>http://yoursite.com/2020/03/08/model/</id>
    <published>2020-03-08T02:02:42.000Z</published>
    <updated>2020-03-08T02:02:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>由于疫情的原因啊，我猜大多数人都跟我一样，在家里度过，偶尔学习学习。这不，我遇到了<strong>一个如何手动一个v-model</strong>的问题，由此展开了学习。<br>在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：</p><a id="more"></a><p><code>&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</code><br>实则是等于下面的：<br><code>&lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;name=$event.target.value&quot;&gt;</code><br>也就是说，v-model就是<strong>绑定了一个名为value的props和一个事件input</strong><br>            注意：所以在子组件中可以通过props中定义value接受值，然后通过$emit触发input事件传新值并修改。 </p><p>知道了这个知识之后啊，那么我们就开始实现一个自定义的v-model啦<del>~</del></p><h2 id="一、最简单的实现方法"><a href="#一、最简单的实现方法" class="headerlink" title="一、最简单的实现方法"></a>一、最简单的实现方法</h2><p>首先是父组件的代码：</p><pre><code class="highlight xquery"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xquery">&#123;<span class="built_in">&#123;name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><span class="xml">      <span class="comment">&lt;!-- 等同于下面 --&gt;</span></span><span class="xml">      <span class="comment">&lt;!-- </span></span><span class="xml"><span class="comment">&lt;son type="text" :value="name" @input="name=子组件传回来的值"&gt; --&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><span class="xml">import Son from './son'</span><span class="xml">export default </span><span class="xquery">&#123;</span><span class="xquery"> <span class="built_in"> name</span>: <span class="string">""</span>,</span><span class="xquery">  data() &#123;</span><span class="xquery">    <span class="keyword">return</span> &#123;</span><span class="xquery">       <span class="built_in"> name</span>:<span class="string">'ydw'</span>,</span><span class="xquery">    &#125;</span><span class="xml">  &#125;,</span><span class="xml">  components: </span><span class="xquery">&#123;</span><span class="xquery">      Son</span><span class="xquery">  &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></code></pre><p>然后是子组件的代码：</p><pre><code class="highlight pgsql">&lt;<span class="keyword">template</span>&gt;  &lt;div <span class="keyword">class</span>&gt;      &lt;<span class="keyword">input</span> <span class="keyword">type</span>="text" :<span class="keyword">value</span>="value" @input="$emit('input',$event.target.value)"&gt;  &lt;/div&gt;&lt;/<span class="keyword">template</span>&gt;&lt;script <span class="keyword">type</span>="text/javascript"&gt;export <span class="keyword">default</span> &#123;  <span class="type">name</span>: "",  props:&#123;      <span class="keyword">value</span>:&#123;          <span class="keyword">type</span>: String,          defalut ()               <span class="keyword">return</span> <span class="string">''</span>          &#125;      &#125;  &#125;,  data() &#123;    <span class="keyword">return</span> &#123;    &#125;  &#125;,  components: &#123;  &#125;&#125;&lt;/script&gt;</code></pre><p>父组件中我加了一个注释的代码行，其实是帮助我自己理解的，不知道有没有小伙伴跟我一样，第一次看的时候压根不知道它在做什么的？哭唧唧。</p><h2 id="二、使用watch和-emit实现"><a href="#二、使用watch和-emit实现" class="headerlink" title="二、使用watch和$emit实现"></a>二、使用watch和$emit实现</h2><p>跟上面的一个有些类似，只不过上面是用本身input事件的作用，通过input事件的频发触发传递值给父组件，这里只是将这个过程换成了通过watch监听值得变化，然后通过input事件触发函数事件，函数事件里提交变化的值给父组件。好了，我只需要修改子组件，如下：</p><pre><code class="highlight kotlin">&lt;template&gt;  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type=<span class="string">"text/javascript"</span>&gt;export <span class="keyword">default</span> &#123;  name: <span class="string">""</span>,  props: &#123;    value: &#123;      type: String,      defalut() &#123;        <span class="keyword">return</span> <span class="string">""</span>;      &#125;    &#125;  &#125;,  <span class="keyword">data</span>() &#123;    <span class="keyword">return</span> &#123;      sonVal:<span class="keyword">this</span>.value    &#125;;  &#125;,  watch: &#123;    value(newval) &#123;      <span class="keyword">this</span>.sonVal = newval    &#125;  &#125;,  methods:&#123;    handleModel(e)&#123;        <span class="keyword">this</span>.sonVal = e.target.value        <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,<span class="keyword">this</span>.sonVal)    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><p>通过watch监听props值得变化，赋值给子组件本身定义的sonVal，绑定在input里。然后利用input事件触发函数，提交到父组件。</p><h2 id="三、使用最新的语法，model属性。"><a href="#三、使用最新的语法，model属性。" class="headerlink" title="三、使用最新的语法，model属性。"></a>三、使用最新的语法，model属性。</h2><p>本来我是不知道有这个属性的，就是在网上搜索关于v-model实现方法的时候，就不知不觉的查到这个属性，查看官方文档如下：<br><img src="./model.png" alt="avatar"></p><p>也就是说这个属性是为了回避props定义的value这个名字的。</p><p>下面看看它的用法，我们先看子组件怎么修改：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>&gt;</span>    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"val"</span> @<span class="attr">input</span>=<span class="string">"$emit('change',$event.target.value)"</span> /&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><span class="actionscript">  name: <span class="string">""</span>,</span>  model:&#123;<span class="actionscript">    prop:<span class="string">'val'</span>,</span><span class="actionscript">    event:<span class="string">'change'</span></span>  &#125;,  props: &#123;    val: &#123;<span class="javascript">      type: <span class="built_in">String</span>,</span>      defalut() &#123;<span class="actionscript">        <span class="keyword">return</span> <span class="string">""</span>;</span>      &#125;    &#125;  &#125;,  data() &#123;<span class="actionscript">    <span class="keyword">return</span> &#123;</span>    &#125;;  &#125;&#125;;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>model属性中prop是重新命名传值的名字，而event则是重新命名事件的名字，但是同样的，props中的传值名字必须与model属性中的prop的名字一样。其实只要对比一下第一种方法就知道，vue多出一个model属性是为了value这个名字可以使用。</p><h3 id="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"><a href="#同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件" class="headerlink" title="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"></a>同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件</h3><pre><code class="highlight kotlin">&lt;template&gt;  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type=<span class="string">"text/javascript"</span>&gt;export <span class="keyword">default</span> &#123;  name: <span class="string">""</span>,  model:&#123;    prop:<span class="string">'val'</span>,    event:<span class="string">'change'</span>  &#125;,  props: &#123;    <span class="keyword">val</span>: &#123;      type: String,      defalut() &#123;        <span class="keyword">return</span> <span class="string">""</span>;      &#125;    &#125;  &#125;,  <span class="keyword">data</span>() &#123;    <span class="keyword">return</span> &#123;      sonVal:<span class="keyword">this</span>.<span class="keyword">val</span>    &#125;;  &#125;,  watch: &#123;    value(newval) &#123;      <span class="keyword">this</span>.sonVal = newval    &#125;  &#125;,  methods:&#123;    handleModel(e)&#123;        <span class="keyword">this</span>.sonVal = e.target.value        <span class="keyword">this</span>.$emit(<span class="string">'change'</span>,<span class="keyword">this</span>.sonVal)    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><p>其实也没多大的修改，只是想贴出来而已。那么手写一个v-model我就写完了，觉得有用的同志给我点个赞赞赞赞赞赞呗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于疫情的原因啊，我猜大多数人都跟我一样，在家里度过，偶尔学习学习。这不，我遇到了&lt;strong&gt;一个如何手动一个v-model&lt;/strong&gt;的问题，由此展开了学习。&lt;br&gt;在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
</feed>

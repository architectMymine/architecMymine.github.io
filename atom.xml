<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RadiomM的博客世界</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-07T10:06:06.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RadiomM</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Uzi退役之后有感</title>
    <link href="http://yoursite.com/2020/06/07/Uzi%E9%80%80%E5%BD%B9/"/>
    <id>http://yoursite.com/2020/06/07/Uzi%E9%80%80%E5%BD%B9/</id>
    <published>2020-06-07T10:06:06.000Z</published>
    <updated>2020-06-07T10:06:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp; &emsp;相信很多最近关注LOL电竞圈的人都知道，UZI–永远滴神，他退役了。相信很多人跟我一样，觉得很不舍，也会觉得很突然，不可思议。我相信没有人会觉得他会就这样退役了，因为我跟很多人的同胞一样，希望他夏季赛的回归，然后再次打进世界赛。</p><a id="more"></a><p><img src="./Uzi1.jpeg" alt="Uzi"></p><p>&emsp; &emsp;对于Uzi的印象挺多的，比如说是<strong>那个绕后VN，英文解说高喊：“He still alive！”</strong>，<strong>两届S赛的亚军</strong>,<strong>S8MSI的卡萨</strong>等等。在央视对Uzi的采访中，Uzi说了，他自己最满意的还是那个vn首个五杀。说实话，我看了影片之后才发现，那个vn是真的厉害，也是真的让人心动。更多的情况大家可以<a href="https://www.bilibili.com/video/BV1dC4y1h7at" target="_blank" rel="noopener">点击这里查看视频</a>。在这里我主要谈的是我自己的感悟。</p><h2 id="得到的不是最珍贵的，失去的才是最珍贵的"><a href="#得到的不是最珍贵的，失去的才是最珍贵的" class="headerlink" title="得到的不是最珍贵的，失去的才是最珍贵的"></a>得到的不是最珍贵的，失去的才是最珍贵的</h2><p>&emsp; &emsp;就像娃娃说那样：“无论你现在怎么评价Uzi，等到他真的退役的时候，大家都会对他有敬意。”，在我的印象里，就算他是拿了两届世界赛的亚军，其实他在我心中地位也没有那么的高，我也曾经跟很多喷子一样，对Uzi独揽经济，但是最后因为自己操作而输掉比赛的做法感到恶心。但是，只要用心的看了今年的LPL的春季赛之后，我才知道，其实Uzi他真的很厉害，就像某个人评论的一样，<strong>“Uzi把RNG抬到了一个本不属于他的层次，仅仅是因为Uzi。”</strong>，其实回过头来看，Uzi确实是厉害，打了八年的职业比赛，比赛水准一直没有下降反而提升，放眼看去这么多年，没有一个职业选手能做到跟Uzi一样的热爱这款游戏，他是想赢的，赢了一次下次还想赢得人。即使这样的一个人，网络上不乏有人对他重拳出击，<strong>这让我想起了一句话：“你不可能是人民币，可以做到每个人都喜欢”</strong>,真到了Uzi退役的时候，你都会感慨，一代英雄也会陨落，他真的身上有很多的病，这是连他队友都不知道的病，坚持到了现在，坚持不下去了还是因为伤病而无法上场而感到的遗憾，我是真的为他感到惋惜，也为自己感到可悲，因为我做到Uzi这样的坚韧。以前我可能会想，不就是打游戏嘛，要是给我这样玩，我也是能够坚持的，事实上让我一直玩十几个小时都顶不住，那还谈什么水平达到Uzi这样的高度？<br><img src="./Uzi2.jpeg" alt="Uzi"></p><h2 id="人生难免会有遗憾"><a href="#人生难免会有遗憾" class="headerlink" title="人生难免会有遗憾"></a>人生难免会有遗憾</h2><p>&emsp; &emsp;对于Uzi的遗憾来说，那就是明明自己还能打，水平并没有下降，但是身体不允许他继续这样高强度的训练下去了。他的退役是有遗憾的，遗憾在于并没有拿到S赛的冠军来证明自己，虽然他并不需要，但是他不得不需要。对于我自己来说，遗憾是有的，但是我比较的差劲，Uzi虽然是抱着遗憾的离开了赛场，但是人家在经济上是完全没有问题的生活下去，就算再怎么差劲，也可以靠着自己的粉丝群体开直播赚钱的。但是我不行，我甚至是一个连工作都没有的人，连养活自己都成问题，所以现在的我有什么理由可以这样消沉下去呢？有时候我会抱怨，明明自己回答到了别人面试官提出的问题，而最后却没有得到别人offer，可能是因为2020的疫情造成了他们更需要的是能干活的人，他是他们觉得我是不能干的，而实际上我是能干的。但是现在的我不会这么想了，为什么呢？其实很简单，没有offer说明你根本就没有这个资格去说你能怎么样怎么样，这更像是发恼骚，没有能力者的恼骚。对于我来说遗憾很多，高中的遗憾，大学的遗憾，毕业后现在找工作的遗憾，可笑的是这些所谓的遗憾、后悔却是自己造成的，不论是学习还是生活，我虽然鼓足干劲却没有用尽全力，我虽然精神先进却行动落后，然而这些思想的先进，鼓足的干劲却让我自己没有记住你的行动落后，你的懒惰！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总的来说，这是一篇瞎写的文章，不过是自己从Uzi退役这件事中对自己的思考而已，当然仅仅是思考并不会对自己的进步有多大的改变，让我有行动去写这篇文章的，恰恰是因为我比较喜欢的一个Up主<a href="https://www.bilibili.com/video/BV1CT4y1E7rf" target="_blank" rel="noopener">泛式</a>最近发布的一个视频，他所给我的一个理念是，自由职业其实是跟需要自制力和把握时间的能力，你可以在保证生活的同时挤出时间来做自己喜欢做的事情，其实跟我出去工作的最大区别就是，没事干的时候你只能在公司发呆，但是自由职业可以干自己想干的事情。我希望跟与君共勉，加油!!!!!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp; &amp;emsp;相信很多最近关注LOL电竞圈的人都知道，UZI–永远滴神，他退役了。相信很多人跟我一样，觉得很不舍，也会觉得很突然，不可思议。我相信没有人会觉得他会就这样退役了，因为我跟很多人的同胞一样，希望他夏季赛的回归，然后再次打进世界赛。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活琐事" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>最近找工作的感悟</title>
    <link href="http://yoursite.com/2020/06/03/jobs/"/>
    <id>http://yoursite.com/2020/06/03/jobs/</id>
    <published>2020-06-03T07:16:01.000Z</published>
    <updated>2020-06-03T07:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="哎呀不小心锁上了，只给有缘人看了，来猜猜看密码是多少？" /><label>哎呀不小心锁上了，只给有缘人看了，来猜猜看密码是多少？</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="1a8bbf0206262755995c0051377f7a55b0477d3800f129e78fe7987c4deb7ac1">869a334310f086ab29eb8ee7d85bc3ff89f74dbebed337e86fc5df67bd50031d9e3c9b242c64a8c10644fc58f215b41c51b9af8823869ed472cb0837f8f7aa2dba6fb1b6e17bc2e66631f245b025cf481edb52997947971e206fbce7783c901fbeaae9972faa143f09ff5307205166a0dc37aa20b63fe1eb8f5ed69b3f739d23a0741442f0b4c50f3940123e5fd93ec71e3d461d28e426efeb8c971a34f74f6b67af91f7c4331c2425b1d902ed9c59c952d31c02dbcb1cca2f092b08ce9d3b6f27dd583b2e31d63e0aa76ec7b4b4c7a2bacf9a6c6da1b78de7a8f06b748525d0e2ad27e27b44d74a8bbeddd817eaac7d74fcb4152d987a01d398ee09f8f463aa36289a9e2d5a45417baaca7e9a7302691cc528c75daebd49ec209a22bc64f4f94a71aaeacaa96f0f23266d947cda8e5864ef619335e72ec1cc8fcac12981ef054cebafb3348b2188b24d59bc81aaaf1eb29dd912282ad012857f6089c7b3ac6f551acb9ed9c3222d923445262d4793e235fb11f3c4224602a90efa3abc179384292cbfcaaffe4a06ae1415c591b950a197a53c745db7a325ecbe241cd2408f9cc23f8f2c8210a6e8728dca74279faa4ea735d717efbe5562f24d05b936d338e98adab96402bf5b0a79b824b08de2c46f329e9655ba449b93a5b2baed31a958f45fbc9c64a9504bf7ad89ecaa1ecfac1bb58a3f0bc4b89708201b8c9f945c647b0eddadcb2bbbc7dd84631485ee990449026fd78f39b9e391e5afc2b063b4ec91850bf3c525657c5462b48aee7c9d8027017c7f377d2e681a8e1a07e68090791b91c10b7d4ca9fec0dc5d536a1383ed06eb6ffeaacfa8aa0387e78bd36a9b1395af92c6e857662b5293b85c68ee8d304826b010e8ee70ecb130b0447cb2b2a846ac8d9b91478faba3987b06fbaa9562e9b12fac20d8bcdb7e6cf9b218cccf99810ecc0aac04e87c65a1c330b90c5642362e916057ef392dcebd8959d20d12f2b5a270e390687fdc75a6c87eb336b6619c46631472ed7dceeebf042c6b77cc25ea777f6b2a6aa25dcf0fef4a6db71a74efd90cf5ea9a95f2482c9beda4d6f7f86608018c5f1501490f6ae1b9409a282656a24d3bc86b25d807f151cb7ce570f6b9a3ecd9e12503625c7a61ff8138f381074583ac12be9440e2ab5a2bf7e042921576e00638861a385cf02f910d702a04b4c2ae41f5aa2774a16be571c8c401c1927959aae2d036d373ca0e93efaf2e489ea1b4ad0514c4e071ee086a9e69baf0383d840243df2c1b909e96c71e19fddef4509986db70c8a98f35d7b8a15aba3d80930b8ec9290b89aad0d7e9f4c3cb7d62253e4b2b7018b45a88b3d5238f35d79747d5b293f30a17986153a61f0f683c4900655c42a45f14bcef143a80437010aebae9659967a324fe466f07791b64207a8c562485de3a971f423c6e5ea997459bdfe68d7d47857b32a77f9be8d77d2accddcc4f89bcfe0e392e0b95f8d7012b7d891454105df167bf1ff5b1334eb99c9af9d01ff32089bbc9a610430a80a564f74d259cebe0a5bca3c440b7ec2cf3b2565739c3d234854d9966a71effcd43ec12b617ea55284328f1f7858edd8689117826055820d8c73daf6d823346004bbf1bf716fcf9a89c161a1ab56aa39b56df5caaf7612ca26feee20c1a61448ca3a212181e68bd5a7cc5261d301b30333cf372d294403c37078ac2a93e25ff1f2c506117bce628778d241be5cc64afd475bafd5e6ce48f608b635d469610a17c239afe9c667f35e052bf2d70e11f464d405b0f3866c174b30f929d79da4e3e7097e12cf45ae24b0e4656b497e11d640a2d6c2691974ef896d2d616d7e697129529622c365b999b5573fe45798740368f668666e864c2cbe1ee71cf24b36276041b9c890cd241f24bad6f57a4553701310c7d9565c95b94f3a10ca9a68536fb074be7cedcd8cf3119d03d4ab7c06fee24bfc7403337e5826824df9dc416451c0dc5a7b7ca36fef64bc41e84a5b65372acca7ba8feb98450b9781b11a8032455cea89812add5d6ae58cb2c69a0d6352c136bb1ed48a551602200cac08b573393645ef8c0fae92cff0ceccb040eedf8daa142b8b32c9017c9231c5a28c66fb0bc4faf291f84ce50f0ecc0118c749ab42f5ed347a696b85a4b96913c1a65f8518dde77f23d77f837a17e7b19bbb4effacb3f448b28c69f17ea20090ce2cdffddd351549fa8f96b58485a6ca68f477f3defaaebff2772d8638df567a2725b3f21f3cf467f6c57847c51eade931b41d3b143b1798576f64224282a4d0eedf978df4f73282462f24a2d2bac1d8a0d63689e0270853c1694bcae07a121b19f9798f43589017198ea8d81dcf222e12a1813023825508aa63f08f1b888e08326eb49b4ef080fef52f038f59268744354747765cd99b3601cd8f2a4affbc08260e0cb1cbbd621f4fdf876c68862c555e2cbc0e92673865f1ae53937d77821364ebb1c3b9be363b786202f8205e2c41ecef64bc5410bbbf6613e0e70033a0b8b963c52353b2e78303ba6e8da3133cbc9a22b048c17dc567d32c2e5732f66dbe89ce8ceef2b967841bca55f659c99d408290021a34942ee5652beb7109993a4f259738a23fbf169f6c3d3965f8d10a4256c6e5f787f57ff791218fb8d243402a8d93b4ad31079a34cec9fbaafd28141a0c7474a04e2ee3363882600bf3dfac2ab074270f44980c3d35a03dfac60d4f858179a2c7112717dddb50ff5a658e789d6bd3c814a0eefa77d37e3f708a5ff4e0a2d06165fbcf56fdbc19cbd90f02a6c20dddb314937eaa2dad47f5b7ac90e8cec7f933be1bda2d9b408ed02971d870bc66112100cd8ccde5a60a1ce2e947c5df174acc4dc914d88208799aefcf178fa7a68648a98f85f4f76119080d4a50d6923ea80b540240bc2ada5e00226ab3af2c7dbbc9d6b7ee86edaadb0054530dd69897f07b37ea49aeddc0f734f01f57085064a56b27c700701cce7b4ae2ba8a9107d892f8d86879e8c4207220134d74c9ea90c1063af4eb7d620f2040124e629c0c07cc976437401e2869bda5eee1d878b4edacdc15b568768f34e368eee3d8b1a1221c510d78f88250e4bbc9d3eb037cb9f32fd83fa836311c7df720b751f638ffc6c945be67e2ced9679785c5c39243ac17e5dc2f7a2332fd464e8ca200d9000db7e9aa6435c3c972a40cb7c2f73934c5fdb7cd9f43c7a7c2f2c8c2a7ee86514cb1033c7b94323fc7aaba0c36ad2aa742a394531604a59bb338826fdb7eed0d81a307ca0e4c4a63988dd4460c674bc750633b764c61850443a28ca04644c33bb2a196a94c55287613e88554953c8901dc8c05f6e836db92c1616e2797587f37e9f09c61f69ea4edfa8914362821827895e2b27c74123ebffb61f4afd23bcd8ff080f69be945c4de5f339f78dd431f573ca342c01058f82675f6802fd867f0dbf2c1b57bb7986975f4093579ed4550a16cefca97a616b2e79316a30a99c8211cf2b958eac12d55b5aef1f5a48ef87c2dcfe9e8aad913e384eda46fd48874aae6704554e21f1231318942f008b060af5ffb6fea27c3e457fab43bcd7d900c3d072155c2fb3160636d481a1e01b19fbc452254ab77b582f451cbe1472c042e9f6434c6646331bac5752968705e65bd7290f90346fd79f9dbd21630effc8d60cedc1fd0cbe47ab67b097567b43d8e15188e79bec0fcaed42bd2a77db0dae80226d8b1a8a9d319c94b20d5dfc2b30250fa9711e52feaf9d4196a6524570aa9b55090ffd68d36d74eafbe3aedf78f8f86d4a64250ca7a3739f1a28b9568b6c5addd6b5ae23c2c2368f0eb789e115713ebd4b5a8300940c286008fd8776ada32bc9adc41914ee6c8dbcaf45fcab918505d05924d0219bc61b842a778f9c4c09b9353708c10a599453d33e9a2c71bb699fbe5a421752e3f4b620a5d2bfa3c5640f74a9b3401d83e0fc288f42fb1ebb7c81d618938008a43ced751f20f12d8fd1c6b2a2d9fa2f9df9af9ce026c3d2009296d714480d5b19025763987afa0dbead66d46acb528cf39ec67582092da8c28ee255a18c536e50039205a5a16459375550e47bd6554fe189fa708a1cfb123eaa2b4de1bbffe9c54d34ee1a181defc4c391fc73c46ffe2a1148e73347159c00553ed565c2b0499489c2965d9e6abb8a9e3cdbd470cc330f5f60d108e45f3fa5a639e2092e66fbda216406c4751778169fe9fe991b66a59d0c9e0c4ebe5e1474751abc6958ad1a94a420361b95573a61707b3371fcef329c3932b5c2e24bcce3200271509b4e31eb7a7754f0765af6eff914434fe83225974e576b7cd7d785537431f5e911be1636897fa743268be37ddaec4995c0e0da8ab0058a153a54d556566ccd5d49efeecc5a7dc43b64d9682be512423c02e0941fb354550b0e0e6f5a67f0b825d79cc8e6a51b27cd9179461a24c798386aaf52039472bc53ca26a4924021ffa829a2f076bfaf71336e78ea6f0d5641c319007e8d7dcdd2bd8c7f179d53b3b2969865d4c2306490ad9feb70c00773d6b176061d9cb9015bd911ad1929ca1f10e0ecdc1b073144e5b2af1d764b8d9b1039552b52080af9ba999d5ad934d7fb0b301fd6375960e9bbc54a5f326120416094830d748efadc9c64a26e2f4a6b3130412bfb0380e450234d26f1fcaeea0bdb3bb0477cf0dfc136b0f7ee2d12b398705d446b36142f2dd3faa21810e2c7875dfc764c987daf42aa5dbe96d6c14c476e1eff3363b1d41870231aea61ad56d5008249306eb93b1538b2c61f6e75e874e2e176f6c66a8084c184b0efaa679211b0ad3303bc42c1ca32e01d68a4cb175767467e53a89fbf4ee38650ba081d0aa23600a1a7dee8fd00231f814e7fe2490a90a9f1cfc5633982c8c19ff612e7b296c1a1d19e3aa9839622b616fc953f143018333cf9e621e533fda9f933f531e516ed765be59e015da7a189a7b281cc47b0904bd78e0e5e97b090bcf55d8f1f878d36fe9ef88834c5997c61dc580283e6709d8eb8458fa3de10962fbb2a952d47911a6a7c0a21d1e62a9e642981222adc6ea2e1f5d2ed7bc48e851f2ea8e261c795ac56556178a8d3eb738905a11aab8b2bbf5070240171aa73465ecac40facb5635faf85d43717402e5b391b7e453d31235acedfcf5eaf46e37607583574ebf7fc9591a443026fb1bfd29103cbc2f63368da5c4c27a29638156ec4543a3f6ddebc08bac3d60c98c9cc481ab05509859428e0361f6ee6086d26185b58ee25c771da6039c702d78fc780c82b524e6134e5abb75f5bd4c5f8b69ab957f7f2d92051e895658efb67c0b4996a1e7fc40c5f5199df07fd3313568fc874a77458d482874a856488961e1c908fa47778b12671655cc38419f1ea64cfc7d3a12d6a65215230a6252057fd97d405dfb54ea0a96fe1c2172185c8f8a732ba12a1e8a819231845389c8d81bf0f3104442e46751743508b11d6ff7f804ab2c8298438e80ead7e198d237fc5e32a4741ecb62670559f20e7988cab3f59b46a2c7e5c4db00ad48cb279c3d1e8c9b06813ecf5e00484448b3d9940e2991fd90b31545d811e35127d9615185265c65dcff26d07c98c5c033de90d0d74ec3874dc8c927beda6bb61bd1b6ed7388acca218b1b252746a25fd4c1e03bef914b5686254c75d979def17fb723c9127e3bdeedf22a3cf52c422463e7c5cc769bff91db64832a781587ffdbe8d930e1dc786b8ea4675ce1aa360675d4e546c73493faa60e0d7b348544def0da3677aaf824872b70dcfb643b87cdca76fbf0c741474de84ccd0bce98069f52eda8349c63719937b4f66bdaf3c3169ef92b912c1c6f2dfcabff4e1307ccdc610775c2c96691f312489bda7de28a08c519719ab62b6c30313f28fe16cec73f985f5c6d13204478c1ae1a464596e2e482a589bcb1311c47134dce67a4e793216995a9429c5c5224c632ef66be916bb2db4fbe5977ab310fb2e88f18d3ad7be2c2dace21dded3b786bebf87d621d26eba6d16fec9c7b7a9852eeea92e53fd41383207a7a04e3e467f762b895d55190e133fdb4b36a550f9ad45ae11e65427daa9a7d995441f162264f2f60a0e66a51de9f0b85e01f5d8be8cc66f2bda4dcd450aed74fbf81869cbdb9dbba244fa7dcee12d6d8ab1eb28e93f45ccb7fffd476e102077a4d34d1407830d6c6c40e2000068a81e30a0bec61565a4b50dd9d7e37d42f65e6e4ce637dd8b4ce1111e0b8009e270a9e1d28650f0e606e628acb859a9ae00f05cab03a823ebbb405385bf97c6739972706282c90ede0bf6a93ff69cf25941eb5ee7c5e6e6e76df9b8a9dacd95980eb4134ae222163d70f7953a19043b74348e76f1b6559e4befc0ed3e0561367d433a39cb169da155da06c36c076822995c2fea2c383ec9b4255e742ab77427b1f23fc7c5db695c38cd8c07f6d285900f68856a1e17774bad9061165e0c1d5db537b95eb01b05846896153212769bde0408b3585accb505069663240541a4b8840112a6aa8759453e14c3de5a7b235caecf9eafd10e8320c11f9a481870c1b6fb7578613bbf2f62fb12aedf6c8507efdc00d4d9e6825c39bd7fb26773b19ddb1cf9d8572efee1c497303fcb7ced6dfab674f29d0c209f65913952c71251b8882888cc3a54f1cf276f41c915685dd22a163e5f09b6398ef524cb8d705fb6483457a79e10a068d7266ffef6d4dca8c3afd5527d5fdded5fc001ee27f85eb41b01e04422d76d83b682f002f90faa445a114e3683d3da8d6393811b33e856c44d5e91d031f21075169413c988db819bf3f55fa13eab595bd6ef6c987e2da505948ef914e0ae3f87b551d3bc6928d53df3a7424ba0e803cec43de1998db719dfd557c2708a5625a180f4ed442c485349cd2f5e1a104941e9b804329836205c7114e4095bac3203ca60beba4158d63884fd520d521c5ffae8811374f260a938b8ae93cb782de7bd677664e74b82d12c649f52589cdfb2c9888e6e99d55d362d1bd58e8adc9aa3cd1e2d179a81aaafb333122b53a6f9c86fc219e6443bf3667fe10fb089f0b2c40587512ab788550dead037e2bdcb52d117dec3ca9a568c91079a76c3a1bb9d92ef240b83a948e40b5893b73fba0c19c36ea576a7402783c35ae4b294c45cd3873cb9731c4c1b37a279d01ebaa81f4d958da9400a72e623f7074e1fd06275841aaf8021c5d6c510a2617dd57fd34dca2c9077a2b9f2d0cea0fe8eaac8ca7481fc46794daf95d1184c3e0afa5a860e68efc69226ad1ad2949ebf0ba6a100b0f49f50df0787803d89d607fd522fe8115ef9dfb3a4e86d03531a771249243ebcbe7b3932603ad1123265a463e9a623235ca8b7be04307900de79fd7daa406055d33ee55cbddba4381809bf004383408ae81142fbf429aee0e83cba64c2f2575f14cd6749db3bdf73a691196e05f6a9f30801c05289b13d55e716f9213ec38eb0325453efa9314fafd766f2c303cbbe5fc68e928d35c065b33c23cc355c792a5a54e22e3aeab941a4481473ba88eb3e616369828f52e60ba04577071300a106218bcf51334051aa8e0ae2a287f4f69b17ca4a89f3479ef9888c8736bcd267e481bfd3fe5ee4e2a3ac329c2ffa050220c0d87514097419325cde4b957627276e4990dd05fb98e65bb1074a919332d079bd64d405b86ad07a6b1887ffb4b56a1bac3cfe03d1a9067b8210b8a68fd756e9f45322a5c4b80e3471738f83d847f7f18014ce2685b611dd0051144ae34aa09525fad3e848ff380c8548392307b19353fa292b139b8a58fb3d642e0768f4f1501526b6b48f335deadb7c9d9794d40da7709b118e7ff413f069b5161f9b1e955d810f4bf694d29023aa9e9404e56eea0e9ac46bbde572226f7b13f21700d79d07abdf1701faeafce0003d3f84eb0496a978620244bda28915f6c135c7836acbabc3f9e7689ea78ec3947862fbb470d33e835ceedd43bdc610416633147c7c7a1083da7772596afa6aa937aac47cfed5175b71cf4a78f1077806142e1c778b073cd573a6b12eafe420cc3508899692c4119fadc1c29cbe41f2f7f35b32003bff152741bc09933848e736322a9617d2c6c4a9febc2ddb3679cfe95423d6587bc6152bc74eadf7fb403e49e66ee6a83ea5ce54bc0e819f203edd6381d097b5eca616812671f3d9dc4653c5f56e953aa9275daac40814740168d43dde72c94c313c715b7656c71d421666c1d53c27b2937bf7ad48b2cc58af41e0d25ed6702b812e271b8f5c3e9e5c7cedb9768492198fdad12c374a6eba93e3af29c7e99ed29bcd3303f8c6f73e39b628fcd8724a76bb44adef3435cef26474d93982351fa12dbdddfddbddf395de06b15dc5d21eff09552aac51ccb487d40a2a94e41f9d3eb31def87849e58d7c07ddb439cfb9fee3c5554fd69085faa48ec0e3fd7e729b8c9872c8379dd5aae36e89e95a39a92726af72462d31236b9448b5ff8e6e123c4116ddf55db71a78d4a85c86c306f59d806816eb14001f1031e5870b3f22874ee774f37ae9a205468d77e7cb268cbceda4244493bee0e2d6fc59615b2d68d43cadc28ec1fc12540ffc99dd131c5c30fc52a05b2455268e8fddea1e61065023e2e965d322a8ede1bd8c91b07977378d145b3a249c7bf5e9eb6803dd668808f33d55b6cba8f40fd2a343373845e00e1c2179f375da39749ba95bda02bd99ec1519f32e62cc391cb7afb6f3ab5de43ef00122247adaa928fcb180e1f8e029484407ac6b3780d04beb9f6d114a50f3c0064b6aa248df818b54e62740549bdf2fcd3f39b719fb486cd140790c6ff7d7c6911aecf6846ff60addd07dde43a963555ec7b4b29060a5381deef176e7c6730dc11696470cf69e1fd7dc81b654df05dcddd6207110b4fe415e3dbdb588bd1124e0c800c5976ca3e1a1264c040a6c8209e5fb4730ffffc3586d3ea74a27b1b658f4a3705ec3e698378eead51f1cd356e216ba27a872122c5a09c8cf1d9c6f335227a3d15665936df0cb02e4893a4eed89af2623e5416c93f6f7db03d1289b10ce8005c1302eb2c498bda15c238cfeacc6db637753b80fbeb78beac3dc76bb5f67e7ddebc8f44ec56e1dbdae8912c3c211e93b6ddb337d534884c4ef9e7a4726670eacae7b879a889bf99cc8d2837cd915e0d53284b0b8bb966c99268c90b7b124dafddb07870432294f1ad3f0473bcf34842b7622ed6515a8b0ee625d61c836c8174ee7b80b2c04ddae67171120bf54d085de36cd839aee3dbb2920c45219b7a8efc17b1a41cd18cf32e2f129f68c4fd5b05a68fabe720e6f75a5a5aca75d561de4e422be028c962e11733563f402984006b69f77eb1e1ba63cc13a04835350b469ec839c2d541871809ddbea138a7424537cd39122bbb317efaea85916e090bac90df154d285616ebcb87bf17e7d3d4eea0f9ed2368091858fb80eca24d9d53629ea079e55c15acb227f8cd71067333e0ad967a3e066e8008ea2c6768ca144a7f986d039711c7ac580427818e485bde5b4c9a39b6ec81ef4470fdfbfdbbb84a4b2ef2c2bcf31706cd02875a1537aca5f0a30e5a9828c2727f3d9e942e9221eb4dde766ed0e3d80a5cebc9c18a9898347b2835857f197b6baa268b8dddceed531a451f0aea934a99589307a1311bbbfa2f6ebd3785492bce2e0a6c770f24edb47eeea1dab23e5a530e02d2fb151abb5c761531f15dd088a59996a15042798cef0c5d7fdf8a549334c67d39d5cedfdad4ccfb79ad2f0cbe5cd6b6105e49e3ae6fdaee0ae33190d2fd3df489a24afdb2174451c118bc33c04939787328889f002cc9154e651481e8e270a900fae3aad7e0cbc93322794cb4e200e9e84e0334c101d20c4fd18a1e6d8c8fb3f11681e5478e32f582cf63b119e3c86288dc7f416addb0d91505ef999c04c2cd487ada2eb2460d64eb996c16ef477ccbdd96e1b3b12adc34c6d52d4ef9ebee7c149f996f6edf3108fe1a7f3f4ae7dd791ea344509c534f7eefda74c606295e00408d687305d19501a679fceab68690b5150a3a015fb7d142ed2a0b7ef9dc9ccbf49d4e195ea48e0e0233ab9f1e9da7c2541b2871ce909b7d27d2ffd3ab615458fe567e7cfc77f1c4cfadf305d765b4c368367c05a7afd37869f640415cbc7ec85f6261f33db162601438a880ce2c991b54fddb2f0de9199d38ee00627707ee73150784af34afec4a255778d7da8e943cb6c1d1897ed26aae14cb260aee026b8e37c211c9e1e276b66ec9c78b9ec0179429b95759385ec331833bee28cd30b711f85b2a0957c300909d977efaf29da2445f0574948cb6ca8c5a1301dc2c0c245d8b4f77cacb46d45e564a45c4bac340d092ec007a1dc7274405de9fcae59dda9c69b783c0d08d756f93233538094e855220a146d06af30aa4fe9d8e586826cd4058bc5b74ef971d17744d76628a6cf9a825d1091de6a425cef56867847c52b228790f3a938595423dc1b8fe9bd387670e0f485885a955c0e2da1067</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      我靠啊，这里居然被锁上了，快联系博主问问密码吧.
    
    </summary>
    
    
      <category term="生活琐事" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
      <category term="tql" scheme="http://yoursite.com/tags/tql/"/>
    
  </entry>
  
  <entry>
    <title>建议改成：this的全面解析(二)</title>
    <link href="http://yoursite.com/2020/03/13/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2020/03/13/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%BA%8C)/</id>
    <published>2020-03-13T12:28:49.000Z</published>
    <updated>2020-03-13T12:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>article p{    font-size:16px;    line-height:28px;}</style><p>大家好！许久不见甚是想念，仅仅过了两天不到，我又开始给你们写技(cai)术(ji)文章了。<br>上回说到，这this的指向，以及作用域的问题，其实我后来发现这个两个说的好像都差不多，但是呢，过于懒得我就不想改了。<br>所以今天，我就立马给大家介绍this的绑定规则！！！是不是好高兴，好激动，甚至有点想打赏我了。好的，我自恋了，下面直接开始。</p><a id="more"></a><p><img src="./jienigui.jpg" alt="杰尼龟-冲冲冲"></p><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>虽然我上篇文章粗略的说过，理解this的绑定，需要知道函数的调用位置，才能确认this绑定的对象。<br>下面是《你不知道的JavaScript上》中的一个例子：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//当前调用栈是：baz</span>    <span class="comment">//因此，当前调用位置是全局作用域</span>    <span class="built_in">console</span>.log(<span class="string">'baz'</span>);    bar(); <span class="comment">//&lt;-- bar的调用位置</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//当前调用栈是：baz -&gt; bar</span>    <span class="comment">//因此，当前调用位置是在baz中</span>    <span class="built_in">console</span>.log(<span class="string">'bar'</span>);    foo(); <span class="comment">//&lt;-- foo的调用位置</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//当前调用栈是：baz -&gt; bar -&gt; foo</span>    <span class="comment">//因此，当前调用位置是在bar中</span>    <span class="built_in">console</span>.log(<span class="string">'foo'</span>);&#125;baz()； <span class="comment">// &lt;-- baz的调用位置</span></code></pre><p>学习JS的同学，多少听过栈跟堆，当然这不是本文的重点，但是为了照顾同学，我决定以后出一篇（有机会的话，嘿嘿）。</p><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>接下来我们就会看看在函数的执行过程中调用位置如何决定this的绑定对象。<br>主要分为了四个规则，下面会逐一分析。</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则。</p><p>先来个简单的例子：</p><pre><code class="highlight javascript"><span class="keyword">var</span> a = <span class="number">2</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;foo() <span class="comment">// 2</span></code></pre><p>明显这个例子，就是算是初学者也会说的出答案。这其实就是默认绑定的一个最简单的例子，那么我们是怎么知道这里运用了默认绑定呢？可以通过分析调用位置来看看foo()是如何调用的。在代码中，foo()是直接使用不带任何修饰的函数引用进行的调用，因此只能使用默认绑定，无法使用其他规则。<br>但是如果是严格模式下(strict mode)的话,则不会绑定到全局对象中，因此this会绑定到undefined</p><pre><code class="highlight javascript"><span class="meta">'use strict'</span><span class="keyword">var</span> a = <span class="number">2</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;foo() <span class="comment">// TypeError: this is undefined</span></code></pre><p>但是在《你不知道的js的上》中提到了一个很微妙的例子，就是假如调用位置在严格模式(strict mode)下的话，则不会影响到默认绑定。</p><pre><code class="highlight javascript"><span class="keyword">var</span> a = <span class="number">2</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="meta">    'use strict'</span>     foo() <span class="comment">// 2</span>&#125;)()</code></pre><h3 id="秒杀默认绑定的技巧"><a href="#秒杀默认绑定的技巧" class="headerlink" title="秒杀默认绑定的技巧"></a>秒杀默认绑定的技巧</h3><p>对于初学者来说，就会问到：’有没有可以立马判断到这是默认绑定的技巧啊，我怕我脑子记太多不够用啊。’<br>既然你诚心诚意的问，我就大发慈悲的告诉你：’有！马上给你安排上’<br>在下面的三种场景下，this会100%指向window：</p><ul><li>立即执行函数（IIFE）</li><li>setTimeout 中传入的函数</li><li>setInterval 中传入的函数</li></ul><p>只要看到判断this的题，没必要第一步就去老实分析这个this绑定到那么对象上，而是应该先定位<strong>this 是否出现在了以上三种类型的函数里面</strong>。如果是，那么想也不想，直接去对应 window 就好了～</p><p>做题快感无非是秒杀嘛，不然为什么那么多人喜欢看<a href="https://baike.baidu.com/item/%E4%B8%80%E6%8B%B3%E8%B6%85%E4%BA%BA/1966105?fr=aladdin" target="_blank" rel="noopener">一拳超人</a></p><h4 id="立即执行函数（IIFE）、"><a href="#立即执行函数（IIFE）、" class="headerlink" title="立即执行函数（IIFE）、"></a>立即执行函数（IIFE）、</h4><p>所谓立即执行函数，就是定义后立刻调用的匿名函数（参见下面这道例题里 hello 方法的函数体里这种写法）。</p><pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">'RadiomM'</span><span class="keyword">var</span> me = &#123;  name: <span class="string">'ydw'</span>,  <span class="comment">// 声明位置</span>  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">`你好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)  &#125;,  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    (<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;      <span class="comment">// 调用位置</span>      cb()    &#125;)(<span class="keyword">this</span>.sayHello)  &#125;&#125;me.hello() <span class="comment">// 大家再猜下输出啥了？</span></code></pre><p>看到这里，我想你必须马上立刻给我喊出答案，那就是RaidomM。如果你不是立马想出答案的，我建议你再好好反省一下！！！！<br>好吧，你该反省完了，那么我接着说。</p><p>其实，即便不考虑立即执行的匿名函数这种所谓的“特殊情况”，大家按照我们上面的指向原则来分析，结果也是一样一样的。 立即执行函数作为一个匿名函数，在被调用的时候，我们往往就是直接调用，而不会（也无法）通过属性访问器（ 即 xx.xxx） 这样的形式来给它指定一个所在对象，所以它的 this 是非常确定的，就是默认的全局对象 window。</p><h4 id="setTimeout-和-setInterval-中传入的函数"><a href="#setTimeout-和-setInterval-中传入的函数" class="headerlink" title="setTimeout 和 setInterval 中传入的函数"></a>setTimeout 和 setInterval 中传入的函数</h4><p>众所周知，其实setTimeout和setInterval中的函数机制其实没什么区别，他们就是兄弟，既然是兄弟，那我就只拿一个兄弟setTimeout开刀了：</p><pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">'RadiomM'</span><span class="keyword">var</span> me = &#123;  name: <span class="string">'ydw'</span>,  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log(<span class="string">`你好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)    &#125;)  &#125;&#125;me.hello() <span class="comment">// 你好，我是RadiomM</span></code></pre><p>是不是觉得好神奇？我们的 this.name 明明看起来是在 me.hello () 里被调用的，结果却输出了 window.name。 setTimeout 到底对函数做了什么？</p><p>其实，我们所看到的延时效果（setTimeout）和定时效果（setInterval），都是在全局作用域下实现的。无论是 setTimeout 还是 setInterval 里传入的函数，都会首先被交付到全局对象手上。因此，函数中 this 的值，会被自动指向 window。</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>所谓的隐式绑定其实就是函数调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。<br>是的，概念就是这么拗口，直接上代码：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;<span class="keyword">var</span> obj =&#123;  a: <span class="number">2</span>,  foo: foo&#125;obj.foo()  <span class="comment">// 2</span></code></pre><p>是不是很眼熟？没错，上一篇文章可是已经做过例子了！！</p><p>首先需要注意的是foo函数的声明方式，及其之后是如何被当做引用属性添加到obj中的。<br>但是无论是直接在obj中定义还是先定义在添加为引用属性，这个函数严格来说都不属于obj对象。</p><p>然而，调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象”拥有”或者”包含“函数引用。<br>没错，这就是隐式绑定规则，将函数的this绑定到了上下文对象中（如上面obj对象），所以this.a和obj.a是一样的</p><p>但是有一点是值得注意的，那就是对象属性引用链中只有最接近的一层有效。看下面的例子：<br> <pre><code class="highlight delphi"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span><span class="function"><span class="comment">    console.log(this.a)</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">var</span> <span class="title">obj1</span> =<span class="comment">&#123;</span></span><span class="function"><span class="comment">  a: 12,</span></span><span class="function"><span class="comment">  foo: foo</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">var</span> <span class="title">obj12</span> =<span class="comment">&#123;</span></span><span class="function"><span class="comment">  a: 22,</span></span><span class="function"><span class="comment">  foo: foo</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"><span class="title">obj1</span>.<span class="title">obj2</span>.<span class="title">foo</span><span class="params">()</span>  <span class="comment">// 22</span></span><span class="function"><span class="title">obj2</span>.<span class="title">obj1</span>.<span class="title">foo</span><span class="params">()</span>  <span class="comment">// 12</span></span></code></pre><br> <img src="./qiguaidezhishi.jpeg" alt="奇怪的知识增加了！"></p><p> <strong>注意了，要是面试问到了，你记得一定要说是我告诉你的！！是的，这会大大的加分！！！</strong><br> <strong>什么？你不信，那你可以收藏一下，关闭网页了。</strong></p><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p> 一个非常常见的问题，或者你平时刷题也会看见的。表现大多是<strong>被隐式绑定的函数会丢失绑定对象，也就是说<br> 它会应用默认绑定，从而把this绑定到全局对象或者undefined上，这个取决于是否是严格模式（strict mode）</strong></p><p> 准备好了吗？接招<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);&#125;<span class="keyword">var</span> obj = &#123;   a: <span class="number">2</span>,   foo: foo&#125;<span class="keyword">var</span> bar = obj.foo  <span class="comment">// 函数别名</span><span class="keyword">var</span> a = <span class="string">"Oh My God"</span>bar(); <span class="comment">// ?</span></code></pre><br> 来吧，多读几遍定义，来说说你的答案是什么？</p><p> 没错，答案就是”Oh My God”，你猜到了吗？什么！？你没猜到，那正好，不然我没法写下去了。</p><p> 看清楚了！虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。什么意思？就是bar()和foo()其实是一样的。<br> 看到foo()，按照我们上面说的，明显就是一个默认规则了。</p><p> 来点开发的时候经常用到的，就是传入回调函数时：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);&#125;<span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;  <span class="comment">// fn其实引用的是foo</span>  fn() <span class="comment">//  &lt;-- 调用位置</span>&#125;<span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>,  foo: foo&#125;<span class="keyword">var</span> a = <span class="string">"Oh My God"</span>doFoo( obj.foo ) <span class="comment">// "Oh My God"</span></code></pre></p><p> 参数传递是<strong>按值传递的，而且算是一种隐式赋值</strong>，因此，从结果上看跟上面的例子没有两样。</p><p> 这时候你就可能会问：“哎呀，这是我自己定义的函数，如果不是自己定义的函数会怎么样啊？”<br> 答案是一样的，没有什么区别的，把setTimeout兄弟抬上来：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);&#125; <span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>,  foo: foo&#125;<span class="keyword">var</span> a = <span class="string">"Oh My God"</span>setTimeout( obj.foo, <span class="number">100</span>) <span class="comment">// "Oh My God"</span></code></pre></p><p> <strong>JavaScript环境中内置的setTimeout()函数实现和下面的伪代码类似：</strong><br> <pre><code class="highlight reasonml"><span class="keyword">function</span> set<span class="constructor">Timeout(<span class="params">fn</span>,<span class="params">delay</span>)</span> &#123;  <span class="comment">// 等待delay毫秒</span>  fn<span class="literal">()</span>&#125;</code></pre></p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p> 显式绑定无非就是用call、apply、bind函数，将this绑定到指定的上下文对象。这三个函数的第一个参数是一个对象，没错<br> 就是给this准备的，接着在调用函数将其绑定到this。<br> 先来个小栗子：</p> <pre><code class="highlight delphi"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span><span class="function"><span class="comment">  console.log(this.a)</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">var</span> <span class="title">obj</span> =<span class="comment">&#123;</span></span><span class="function"><span class="comment">  a: 2</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">foo</span>.<span class="title">call</span><span class="params">( obj )</span>    <span class="comment">//2</span></span><span class="function"></span><span class="function"><span class="title">foo</span>.<span class="title">apply</span><span class="params">( obj )</span>  <span class="comment">//2</span></span><span class="function"></span><span class="function"><span class="title">var</span> <span class="title">bar</span> = <span class="title">foo</span>.<span class="title">bind</span><span class="params">(obj)</span></span><span class="function"></span><span class="function"><span class="title">bar</span><span class="params">()</span>            <span class="comment">//2</span></span></code></pre><p>看到区别了吗？call和apply直接使用即可，而bind需要变量接受返回值，然后再调用。然后我就可分类讲了。</p><h4 id="改变后直接调用函数"><a href="#改变后直接调用函数" class="headerlink" title="改变后直接调用函数"></a>改变后直接调用函数</h4><p> call和apply都是可以直接调用实现的，那么它们有什么区别吗？</p><p> 看下面小栗子：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>)</span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" go "</span>+ a +<span class="string">" and "</span>+ b)&#125;<span class="keyword">var</span> obj = &#123;  name:<span class="string">'RaidomM'</span>&#125;foo.call(obj,<span class="string">'成都'</span>,<span class="string">'广东'</span>)     <span class="comment">// RaidomM go 成都 and 广东</span>foo.apply(obj,[<span class="string">'成都'</span>,<span class="string">'广东'</span>])  <span class="comment">// RaidomM go 成都 and 广东</span></code></pre></p><p> 可以注意到，call与apply只是传参的方式不一样，但是函数内部获取参数的方法确实一样的！<br> 在这里先留问题，如何实现一个call或者apply呢？可以解决上面提及到了<strong>隐式丢失</strong>的问题吗？</p><h4 id="改变后返回一个函数"><a href="#改变后返回一个函数" class="headerlink" title="改变后返回一个函数"></a>改变后返回一个函数</h4><p> 再看下面的一个小栗子：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b</span>)</span>&#123;  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a ,b)  <span class="keyword">return</span> <span class="keyword">this</span>.a + b&#125;<span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>&#125;<span class="keyword">var</span> bar = foo.bind(obj)<span class="keyword">var</span> c = bar(<span class="number">3</span>) <span class="comment">// 2,3</span><span class="built_in">console</span>.log( c ) <span class="comment">// 5</span></code></pre><br> 可以看到，bind会返回一个函数。这个函数可以暂时理解为foo（实际上并不是一模一样的），然后你再调用函数传参等。</p><p> <strong>一个可以值得提到的点</strong>，那就是bind的绑定永远起作用的是第一个<br> <pre><code class="highlight javascript"><span class="keyword">let</span> a = &#123;&#125;<span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;fn.bind().bind(a)() <span class="comment">// =&gt; ?</span></code></pre><br> 如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式<br> <pre><code class="highlight javascript"> <span class="comment">// fn.bind().bind(a) 等于</span><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> fn.apply()  &#125;.apply(a)&#125;fn2()</code></pre><br> 可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。<br> <pre><code class="highlight javascript"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">'ydw'</span> &#125;<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;foo.bind(a)() <span class="comment">// =&gt; 'ydw'</span></code></pre></p><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p> 如果简单说的话，可以直接看一下代码：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;  <span class="keyword">this</span>.a = a&#125;<span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)<span class="built_in">console</span>.log(bar.a) <span class="comment">// 2</span></code></pre></p><p>当然，这其实没有那么简单，其中涉及到<strong>构造函数</strong>，<strong>new实现了什么的操作</strong>，<strong>原型和原型链</strong>等等。<br>但是你现在只需要知道，使用new操作的，那么this就永远绑定到创建的实例对象上面（上面的代码就是bar）</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数是ES6新提出的一个<strong>带返回值函数的简写方式</strong>，它的this就跟词法作用域一样，一旦绑定了，那么它的this，<br>就永远绑定在那里了。上代码：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;<span class="keyword">var</span> obj1 = &#123;  a: <span class="number">2</span>&#125;<span class="keyword">var</span> obj2 = &#123;  a: <span class="number">3</span>&#125;<span class="keyword">var</span> bar = foo.call(obj1)bar.call(obj2); <span class="comment">// 2 不是3</span></code></pre><p>foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar（引用箭头函数）的this也会绑定<br>到obj1，箭头函数的绑定无法被修改，就是new也是不行的。</p><p>箭头函数常常用回调函数中。看下面代码：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;    <span class="comment">// 这里的this在词法上继承自foo()</span>    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)  &#125;)&#125;<span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>&#125;foo.call(obj) <span class="comment">// 2</span></code></pre><p>然而在ES6之前，我们解决这个问题的办法是下面的：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">var</span> that = <span class="keyword">this</span>  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)  &#125;, <span class="number">100</span>)&#125;<span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>&#125;foo.call(obj) <span class="comment">// 2</span></code></pre><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>关于优先级，我想直接引用yck的《前端面试之道》中的一张图来给大家看</p><p><img src="./this.jpg" alt="判断this优先级"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于是写完了，其实后面的内容会相对的写的比较少，为什么呢？那肯定是为了之后可以再写文章啦（没错，就是水文章）</p><p>开玩笑的，事实上写起来会复杂的多，而这篇文章的篇幅已经是比较多了，再多的话，你们就没心思读下去了。</p><p>下面开始技术总结（<strong>其实看了优先级的那种图就可以了</strong>）：</p><p>1、函数是否在new中调用（new绑定），是则this绑定到实例对象上</p><p>2、函数是否通过call，apply，bind显示绑定的，如果是，this绑定的是指定的对象</p><p>3、函数是否调用在上下文对象（隐式绑定），是则this绑定到那个上下文对象中</p><p>4、如果都不是那么就是使用默认规则，严格模式下绑定到undefined，否则绑定到全局对象中（ 浏览器window, Node环境gobal）</p><p>好了，看到这里大家也不容易，所以给大家再上一首歌吧！</p>    <div id="aplayer-sLAHsfih" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="722928" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>如果文章有错误的地方，希望小哥哥小姐姐们在评论区指出，毕竟作者的水平确实有限。</p>]]></content>
    
    <summary type="html">
    
      &lt;style&gt;
article p{
    font-size:16px;
    line-height:28px;
}
&lt;/style&gt;

&lt;p&gt;大家好！许久不见甚是想念，仅仅过了两天不到，我又开始给你们写技(cai)术(ji)文章了。&lt;br&gt;上回说到，这this的指向，以及作用域的问题，其实我后来发现这个两个说的好像都差不多，但是呢，过于懒得我就不想改了。&lt;br&gt;所以今天，我就立马给大家介绍this的绑定规则！！！是不是好高兴，好激动，甚至有点想打赏我了。好的，我自恋了，下面直接开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>建议改成：this的全面解析(一)</title>
    <link href="http://yoursite.com/2020/03/12/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%B8%80)/"/>
    <id>http://yoursite.com/2020/03/12/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%B8%80)/</id>
    <published>2020-03-12T05:27:24.000Z</published>
    <updated>2020-03-12T05:27:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>article p{    font-size:16px;    line-height:28px;}</style><p>嗨，大家好！过了那么几天我又开始写文章了，这次给大家带来的是this的全面解析。会不会有人会问，怎么突然就这么高产了？其实是这样的，因为这次疫情的出现，让我原本的计划出现了变动，当然也让我认清了我小公司的老板是多么的抠门。所以接下来的文章，基本都是会写一些面试多次会考的问题。当然，作为前端工程师，那么我们的基本功除了HTML，CSS意外，最重要的就是这个JS中的this。废话说完，那么接下来我们就开始了。</p><a id="more"></a><h2 id="this是指向的是谁？"><a href="#this是指向的是谁？" class="headerlink" title="this是指向的是谁？"></a>this是指向的是谁？</h2><p>在多数的情况下，this指向的是调用方法的那个对象。<strong>简单的说就是谁调用函数，那么this就是指向这个对象。</strong><br> <pre><code class="highlight delphi"><span class="keyword">var</span> a = <span class="number">1</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span><span class="function"><span class="comment">    console.log(this.a)</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"><span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出 1</span></span><span class="function"></span><span class="function"><span class="title">let</span> <span class="title">obj</span> = <span class="comment">&#123;</span></span><span class="function"><span class="comment">    a: 2,</span></span><span class="function"><span class="comment">    foo:foo</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">obj</span>.<span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出2</span></span></code></pre></p><p>上面的代码对于老手来说应该没有什么问题。这里我对新手提点注意的点，那就是foo()的调用其实相当于window.foo()，又因为var定义的变量在<strong>非严格模式下</strong>会自动挂载到全局对象中，<strong>在浏览器中，指向 window；在 Node 中，指向 Global。（严格模式下，指向 undefined）</strong></p><h2 id="this的作用域指向哪里？"><a href="#this的作用域指向哪里？" class="headerlink" title="this的作用域指向哪里？"></a>this的作用域指向哪里？</h2><p>很多新手学习JavaScript的同学来说，都会认为this指向的是函数的作用域，实际上并不是这样的，实际上你看了上面的两个例子之后，<br>你就会发现，第一个符合，而第二个却是不符合的。再看下面一个经典的题目，你可能就有点意思了。（不懂作用域的同学，之后我也会出一篇的。）</p><pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">"zhangsan"</span>;<span class="keyword">var</span> obj = &#123;    name:<span class="string">"RadiomM"</span>,    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         <span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) &#125;;        x();    &#125;&#125;obj.fn() <span class="comment">// zhangsan</span></code></pre><p>是不是答案有点出乎了意料，这大多是因为觉得this指向函数作用域的关系，看x函数在obj对象的属性方法中定义，想当然的以为这时候调用函数x的就是这个obj对象，事实上这是大错特错的，有必要简单的说说，什么是声明，什么是调用。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>看下面的例子：</p><pre><code class="highlight cs"><span class="keyword">var</span> a = <span class="number">1</span><span class="function">funciton <span class="title">foo</span>(<span class="params"></span>)</span> &#123;    console.log(a)&#125;</code></pre><p>没错，就是这么简单，这就是声明函数foo。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>看下面的例子：</p><pre><code class="highlight stylus"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span>funciton foo() &#123;    console.log(a)&#125;<span class="comment">// 这就是调用</span><span class="function"><span class="title">foo</span><span class="params">()</span></span></code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>重要的事情说三遍，建议你大声跟着读下面的字：<br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br>实际上，你读完上面的字，你还是会疑惑，那么为什么输出的就是这个zhangsan呢？其实，我在第一个例子中<br>已经给了提示了，实际上这个x()就相当于window.x()，那么这道题就相当的明了了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>话不多说，直接抬总结上来：</p><p>1、this绑定实际上是在函数被调用时发生的绑定，它的指向取决于函数在哪里被调用。</p><p>2、this的作用域并不是指向函数的作用域。</p><p>其实这篇文章仅仅是入门this的基础，下一篇文章我将会全面解析this的绑定规则。<br>看到这里你可能会问什么会是下一篇呢？因为我写累了啊，哈哈。<br>给大兄弟来首歌轻松轻松。（这篇文章就是在快乐气氛下写完的。学习可别忘了快乐，hasaki！）</p>    <div id="aplayer-gWKctCLu" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="29732992" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>如果文章有错误的地方，希望小哥哥小姐姐们在评论区指出，毕竟作者的水平确实有限。</p>]]></content>
    
    <summary type="html">
    
      &lt;style&gt;
article p{
    font-size:16px;
    line-height:28px;
}
&lt;/style&gt;


&lt;p&gt;嗨，大家好！过了那么几天我又开始写文章了，这次给大家带来的是this的全面解析。会不会有人会问，怎么突然就这么高产了？其实是这样的，因为这次疫情的出现，让我原本的计划出现了变动，当然也让我认清了我小公司的老板是多么的抠门。所以接下来的文章，基本都是会写一些面试多次会考的问题。当然，作为前端工程师，那么我们的基本功除了HTML，CSS意外，最重要的就是这个JS中的this。废话说完，那么接下来我们就开始了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>手动实现一个v-model的不同做法</title>
    <link href="http://yoursite.com/2020/03/08/model/"/>
    <id>http://yoursite.com/2020/03/08/model/</id>
    <published>2020-03-08T02:02:42.000Z</published>
    <updated>2020-03-08T02:02:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>由于疫情的原因啊，我猜大多数人都跟我一样，在家里度过，偶尔学习学习。这不，我遇到了<strong>一个如何手动一个v-model</strong>的问题，由此展开了学习。<br>在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：</p><a id="more"></a><p><code>&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</code><br>实则是等于下面的：<br><code>&lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;name=$event.target.value&quot;&gt;</code><br>也就是说，v-model就是<strong>绑定了一个名为value的props和一个事件input</strong><br>            注意：所以在子组件中可以通过props中定义value接受值，然后通过$emit触发input事件传新值并修改。 </p><p>知道了这个知识之后啊，那么我们就开始实现一个自定义的v-model啦<del>~</del></p><h2 id="一、最简单的实现方法"><a href="#一、最简单的实现方法" class="headerlink" title="一、最简单的实现方法"></a>一、最简单的实现方法</h2><p>首先是父组件的代码：</p><pre><code class="highlight xquery"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xquery">&#123;<span class="built_in">&#123;name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><span class="xml">      <span class="comment">&lt;!-- 等同于下面 --&gt;</span></span><span class="xml">      <span class="comment">&lt;!-- </span></span><span class="xml"><span class="comment">&lt;son type="text" :value="name" @input="name=子组件传回来的值"&gt; --&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><span class="xml">import Son from './son'</span><span class="xml">export default </span><span class="xquery">&#123;</span><span class="xquery"> <span class="built_in"> name</span>: <span class="string">""</span>,</span><span class="xquery">  data() &#123;</span><span class="xquery">    <span class="keyword">return</span> &#123;</span><span class="xquery">       <span class="built_in"> name</span>:<span class="string">'ydw'</span>,</span><span class="xquery">    &#125;</span><span class="xml">  &#125;,</span><span class="xml">  components: </span><span class="xquery">&#123;</span><span class="xquery">      Son</span><span class="xquery">  &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></code></pre><p>然后是子组件的代码：</p><pre><code class="highlight pgsql">&lt;<span class="keyword">template</span>&gt;  &lt;div <span class="keyword">class</span>&gt;      &lt;<span class="keyword">input</span> <span class="keyword">type</span>="text" :<span class="keyword">value</span>="value" @input="$emit('input',$event.target.value)"&gt;  &lt;/div&gt;&lt;/<span class="keyword">template</span>&gt;&lt;script <span class="keyword">type</span>="text/javascript"&gt;export <span class="keyword">default</span> &#123;  <span class="type">name</span>: "",  props:&#123;      <span class="keyword">value</span>:&#123;          <span class="keyword">type</span>: String,          defalut ()               <span class="keyword">return</span> <span class="string">''</span>          &#125;      &#125;  &#125;,  data() &#123;    <span class="keyword">return</span> &#123;    &#125;  &#125;,  components: &#123;  &#125;&#125;&lt;/script&gt;</code></pre><p>父组件中我加了一个注释的代码行，其实是帮助我自己理解的，不知道有没有小伙伴跟我一样，第一次看的时候压根不知道它在做什么的？哭唧唧。</p><h2 id="二、使用watch和-emit实现"><a href="#二、使用watch和-emit实现" class="headerlink" title="二、使用watch和$emit实现"></a>二、使用watch和$emit实现</h2><p>跟上面的一个有些类似，只不过上面是用本身input事件的作用，通过input事件的频发触发传递值给父组件，这里只是将这个过程换成了通过watch监听值得变化，然后通过input事件触发函数事件，函数事件里提交变化的值给父组件。好了，我只需要修改子组件，如下：</p><pre><code class="highlight kotlin">&lt;template&gt;  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type=<span class="string">"text/javascript"</span>&gt;export <span class="keyword">default</span> &#123;  name: <span class="string">""</span>,  props: &#123;    value: &#123;      type: String,      defalut() &#123;        <span class="keyword">return</span> <span class="string">""</span>;      &#125;    &#125;  &#125;,  <span class="keyword">data</span>() &#123;    <span class="keyword">return</span> &#123;      sonVal:<span class="keyword">this</span>.value    &#125;;  &#125;,  watch: &#123;    value(newval) &#123;      <span class="keyword">this</span>.sonVal = newval    &#125;  &#125;,  methods:&#123;    handleModel(e)&#123;        <span class="keyword">this</span>.sonVal = e.target.value        <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,<span class="keyword">this</span>.sonVal)    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><p>通过watch监听props值得变化，赋值给子组件本身定义的sonVal，绑定在input里。然后利用input事件触发函数，提交到父组件。</p><h2 id="三、使用最新的语法，model属性。"><a href="#三、使用最新的语法，model属性。" class="headerlink" title="三、使用最新的语法，model属性。"></a>三、使用最新的语法，model属性。</h2><p>本来我是不知道有这个属性的，就是在网上搜索关于v-model实现方法的时候，就不知不觉的查到这个属性，查看官方文档如下：<br><img src="./model.png" alt="avatar"></p><p>也就是说这个属性是为了回避props定义的value这个名字的。</p><p>下面看看它的用法，我们先看子组件怎么修改：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>&gt;</span>    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"val"</span> @<span class="attr">input</span>=<span class="string">"$emit('change',$event.target.value)"</span> /&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><span class="actionscript">  name: <span class="string">""</span>,</span>  model:&#123;<span class="actionscript">    prop:<span class="string">'val'</span>,</span><span class="actionscript">    event:<span class="string">'change'</span></span>  &#125;,  props: &#123;    val: &#123;<span class="javascript">      type: <span class="built_in">String</span>,</span>      defalut() &#123;<span class="actionscript">        <span class="keyword">return</span> <span class="string">""</span>;</span>      &#125;    &#125;  &#125;,  data() &#123;<span class="actionscript">    <span class="keyword">return</span> &#123;</span>    &#125;;  &#125;&#125;;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>model属性中prop是重新命名传值的名字，而event则是重新命名事件的名字，但是同样的，props中的传值名字必须与model属性中的prop的名字一样。其实只要对比一下第一种方法就知道，vue多出一个model属性是为了value这个名字可以使用。</p><h3 id="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"><a href="#同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件" class="headerlink" title="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"></a>同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件</h3><pre><code class="highlight kotlin">&lt;template&gt;  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type=<span class="string">"text/javascript"</span>&gt;export <span class="keyword">default</span> &#123;  name: <span class="string">""</span>,  model:&#123;    prop:<span class="string">'val'</span>,    event:<span class="string">'change'</span>  &#125;,  props: &#123;    <span class="keyword">val</span>: &#123;      type: String,      defalut() &#123;        <span class="keyword">return</span> <span class="string">""</span>;      &#125;    &#125;  &#125;,  <span class="keyword">data</span>() &#123;    <span class="keyword">return</span> &#123;      sonVal:<span class="keyword">this</span>.<span class="keyword">val</span>    &#125;;  &#125;,  watch: &#123;    value(newval) &#123;      <span class="keyword">this</span>.sonVal = newval    &#125;  &#125;,  methods:&#123;    handleModel(e)&#123;        <span class="keyword">this</span>.sonVal = e.target.value        <span class="keyword">this</span>.$emit(<span class="string">'change'</span>,<span class="keyword">this</span>.sonVal)    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><p>其实也没多大的修改，只是想贴出来而已。那么手写一个v-model我就写完了，觉得有用的同志给我点个赞赞赞赞赞赞呗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于疫情的原因啊，我猜大多数人都跟我一样，在家里度过，偶尔学习学习。这不，我遇到了&lt;strong&gt;一个如何手动一个v-model&lt;/strong&gt;的问题，由此展开了学习。&lt;br&gt;在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>VScode配置git的路径</title>
    <link href="http://yoursite.com/2020/03/03/VScode%E9%85%8D%E7%BD%AEgit%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/03/03/VScode%E9%85%8D%E7%BD%AEgit%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2020-03-03T01:19:47.000Z</published>
    <updated>2020-03-03T01:19:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近才开始用VScode写代码，因为之前用的都是webstorm的，虽然好用啊但是经常需要激活，而且激活码变得越来越难找的，所以就改用VScode的。</p><a id="more"></a><p>开始进入主题。今天装完插件Gitlens的时候报错了，说找不到git的路径。<br><img src="./bVbD2Sa.png" alt="2020-03-03_111734.png"></p><p>经过十几分钟的百度，终于知道如何配置了git的路径了（前提是你电脑已经安装好了git）。<br>1.打开vs的设置<br><img src="./bVbD2UW.png" alt="2020-03-03_112425.png"></p><p>2.搜索git.path，冰灾setting.json中打开<br><img src="./bVbD2Vb.png" alt="2020-03-03_112509.png"></p><p>3.找到你的git.exe的位置，如图这是我的git.exe的位置，将地址复制。<br><img src="./bVbD2Vd.png" alt="2020-03-03_112600.png"></p><p>4.直接复制在setting.json中<br><img src="./bVbD2Vx.png" alt="2020-03-03_112633.png"></p><p>明显这是个报错，不能用单斜杠，而是用双斜杠。<br><img src="./bVbD2VI.png" alt="2020-03-03_112652.png"></p><p>好了，重启VScode就不会报错了，并且可以使用Gitlens的功能了。希望能帮助大家少踩坑，如果有帮助希望点了赞，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近才开始用VScode写代码，因为之前用的都是webstorm的，虽然好用啊但是经常需要激活，而且激活码变得越来越难找的，所以就改用VScode的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="VScode" scheme="http://yoursite.com/tags/VScode/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Sticky footer布局</title>
    <link href="http://yoursite.com/2019/11/28/Sticky-footer%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/11/28/Sticky-footer%E5%B8%83%E5%B1%80/</id>
    <published>2019-11-28T03:36:47.000Z</published>
    <updated>2019-11-28T03:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近发现公司的在内容较小的时候使用的是js，通过过去body以及内容高度对比，动态设置footer的position的属性来改变footer是否存在与底部。所以最近搜索了很多关于了sticky footer的布局。鉴于国内环境大多文章都是抄袭，很多内容都是没有只给了关键部分，都没有给了完整的配置，所以特地写了这篇文章仅供参考，如果文中有什么不妥的地方，请各位指出，我会尽量快的修改过来。</p><a id="more"></a><h2 id="利用margin-top以及padding-bottom"><a href="#利用margin-top以及padding-bottom" class="headerlink" title="利用margin-top以及padding-bottom"></a>利用margin-top以及padding-bottom</h2><p>这是一个兼容性比较好的方法，我个人也是比较推荐的，在pc以及移动端都有良好的表现。<br>css代码：</p><pre><code class="highlight stylus">&lt;style&gt;<span class="selector-tag">html</span>,<span class="selector-tag">body</span>,<span class="selector-tag">p</span> &#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>;&#125;<span class="selector-class">.clearfix</span>:after &#123;<span class="attribute">display</span>: block;<span class="attribute">content</span>: <span class="string">''</span>;<span class="attribute">height</span>: <span class="number">0</span>;<span class="attribute">visibility</span>: hidden;<span class="attribute">clear</span>: both;&#125;<span class="selector-tag">html</span>,<span class="selector-tag">body</span> &#123;<span class="attribute">height</span>: <span class="number">100%</span>;&#125;<span class="selector-class">.wrapper</span> &#123;<span class="attribute">min-height</span>: <span class="number">100%</span>;*<span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">background</span>: red;&#125;<span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;<span class="attribute">padding-bottom</span>: <span class="number">100px</span>;&#125;<span class="selector-class">.footer</span> &#123;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">width</span>: <span class="number">100%</span>;<span class="attribute">margin-top</span>: -<span class="number">100px</span>;<span class="attribute">background</span>: hotpink;&#125;&lt;/style&gt;</code></pre><p>html代码：</p><pre><code class="highlight angelscript">&lt;body&gt;&lt;div <span class="keyword">class</span>="<span class="symbol">wrapper</span> <span class="symbol">clearfix</span>"&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">content</span>"&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">footer</span>"&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">body</span>&gt;</code></pre><p>执行效果自行复制代码实践，这个是经过我自己多次测试发现没有问题的。</p><h2 id="利用flex布局实现"><a href="#利用flex布局实现" class="headerlink" title="利用flex布局实现"></a>利用flex布局实现</h2><p>css代码：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span>html,body,div,p&#123;margin: 0;padding: 0;&#125;html&#123;height: 100%;&#125;body&#123;min-height: 100%;display: flex;<span class="css"><span class="selector-tag">flex-direction</span><span class="selector-pseudo">:column</span>;</span>&#125;<span class="css"><span class="selector-class">.content</span>&#123;</span>flex: 1;&#125;<span class="css"><span class="selector-class">.footer</span>&#123;</span>width: 100%;height: 100px;background: hotpink;&#125;<span class="tag">&lt;/<span class="name">style</span>&gt;</span></code></pre><p>html代码：</p><pre><code class="highlight angelscript">   &lt;body&gt;&lt;div <span class="keyword">class</span>="<span class="symbol">content</span>"&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">footer</span>"&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">body</span>&gt;</code></pre><h2 id="利用position实现"><a href="#利用position实现" class="headerlink" title="利用position实现"></a>利用position实现</h2><p>css代码：</p><pre><code class="highlight yaml"><span class="string">&lt;style&gt;</span><span class="string">html,</span><span class="string">body,</span><span class="string">p</span> <span class="string">&#123;</span><span class="attr">margin:</span> <span class="number">0</span><span class="string">;</span><span class="attr">padding:</span> <span class="number">0</span><span class="string">;</span> <span class="string">&#125;</span><span class="string">html,body&#123;</span><span class="attr">height:</span> <span class="number">100</span><span class="string">%;</span><span class="string">&#125;</span><span class="string">.wrapper&#123;</span><span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span><span class="attr">position:</span> <span class="string">relative;</span><span class="attr">min-height:</span> <span class="number">100</span><span class="string">%;</span><span class="string">*height:</span> <span class="number">100</span><span class="string">%;</span><span class="attr">padding-bottom:</span> <span class="string">100px;</span><span class="attr">box-sizing:</span> <span class="string">border-box;</span><span class="attr">background:</span> <span class="string">red;</span><span class="string">&#125;</span><span class="string">.footer&#123;</span><span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span><span class="attr">height:</span> <span class="string">100px;</span><span class="attr">position:</span> <span class="string">absolute;</span><span class="attr">bottom:</span> <span class="number">0</span><span class="string">;</span><span class="attr">background:</span> <span class="string">hotpink;</span><span class="string">&#125;</span><span class="string">&lt;/style&gt;</span></code></pre><p>html代码：</p><pre><code class="highlight angelscript">&lt;body&gt;&lt;div <span class="keyword">class</span>="<span class="symbol">wrapper</span>"&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">content</span>"&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">footer</span>"&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">body</span>&gt;</code></pre><p>同样的，这里通过<strong>padding-bottom为底部留足空间</strong>，<strong>box-sizing：border-box</strong>是为了不让padding计算在内容里。</p><p>暂时只更新这么多，待我测试一下其他的方法，觉得可行之后，再更新出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现公司的在内容较小的时候使用的是js，通过过去body以及内容高度对比，动态设置footer的position的属性来改变footer是否存在与底部。所以最近搜索了很多关于了sticky footer的布局。鉴于国内环境大多文章都是抄袭，很多内容都是没有只给了关键部分，都没有给了完整的配置，所以特地写了这篇文章仅供参考，如果文中有什么不妥的地方，请各位指出，我会尽量快的修改过来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>如何通过git上传代码到github</title>
    <link href="http://yoursite.com/2019/09/10/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github/"/>
    <id>http://yoursite.com/2019/09/10/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github/</id>
    <published>2019-09-10T03:26:20.000Z</published>
    <updated>2019-09-10T03:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在学习mpvue的时候遇到了一些小问题（课程是慕课网上的Sam老师的一门课，非常推荐。）由于不知道老师什么时候回复我，而且为了方便起见，所以就想通过github代码管理来实现（其实之前是用过的，不过就随便用了一下，所以忘记了。）</p><a id="more"></a><p>期间确实遇到不少坑，也比较让我抓狂。（坑会后面单独写一篇，因为上传码云的时候也有坑，所以就一起写）牛皮扯完了，那么就开始介绍了。<br>由于是要上传到github，所以我介绍的是比较通用简单的方法，那么开始第一步（<strong>前提是你电脑已经安装了git</strong>）。<br><strong>先查看有没有ssh秘钥生成</strong><br><img src="./20190910112420671.png" alt="ssh"><br>一般来说就是Administrator里找有没有 .ssh这个文件。<strong>没有就是还没生成ssh秘钥。</strong>（<strong>像我自己的电脑用户名是YDW，所以就是在YDW里面看看有没有这个文件</strong>）<br>直接在桌面git bash<br><img src="./20190910113010728.png" alt="在这里插入图片描述"><br>其实哪里git bash都是可以的。输入以下命令</p><pre><code class="highlight excel">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"你的邮箱地址"</span></code></pre><p><img src="./20190910113512447.png" alt="在这里插入图片描述"><br>因为我已经生成过了ssh秘钥，所以这是会提示我是否要覆盖之前的秘钥（肯定不要啦我，不然我又要重新配置了。）<br>然后回到之前的目录里找.<strong>ssh</strong>文件夹。<br><img src=".n/20190910113843525.png" alt="在这里插入图片描述"><br>第一个是私钥，第二个是秘钥。这是打开第二个文件。（我是有EditPlus，但是大家也可以用记事本打开，这是用记事本打开）<br><img src="./20190910114252199.png" alt="不要纠结为什么有这么大的矩形"><br>这里我进行了处理（其实这算是个人隐私了。）<br>接下来打开<a href="https://github.com" target="_blank" rel="noopener">Github</a>官方网址<br><strong>登陆啥的就不说了，直接新建仓库。</strong><br><img src="./2019091011464548.png" alt="新建仓库"><br>接下来就是下面的界面。<br><img src="./20190910115222266.png" alt="仓库创建配置"><br>仓库已经创建完了。因为我们是通过ssh秘钥上传代码的。所以对应的需要在Github设置一下秘钥。<br><img src="./20190910115828779.png" alt="在这里插入图片描述"><br><img src="./20190910120018496.png" alt="在这里插入图片描述"><br><img src="./20190910120253553.png" alt="在这里插入图片描述"><br>然后回到你之前的仓库那里<br><img src="./20190910120456576.png" alt="在这里插入图片描述"><br><img src="./20190910120602384.png" alt="在这里插入图片描述"><br><img src=".n/20190910120719132.png" alt="在这里插入图片描述"><br><strong>这时候就可以准备上传你的项目了。下面打开你自己的项目，然后右键git bash。</strong><br><img src="./20190910141146852.png" alt="在这里插入图片描述"><br><strong>执行命令 git init 初始化仓库</strong><br><img src="./20190910141302161.png" alt="在这里插入图片描述"><br><strong>创建上传地址的命令是</strong></p><pre><code class="highlight dockerfile">git remote <span class="keyword">add</span><span class="bash"> origin git@github.com:architectMymine/test.git</span></code></pre><p><img src="./20190910142042873.png" alt="在这里插入图片描述"><br><strong>ssh地址是上面在git里面的地址，查看当前创建地址的命令是</strong> </p><pre><code class="highlight ebnf"><span class="attribute">git remote -v</span></code></pre><p><strong>把项目放入暂存区命令(后面是有一个小点的)</strong></p><pre><code class="highlight dockerfile">git <span class="keyword">add</span><span class="bash"> .</span></code></pre><p><strong>这时候会有警告，其实就是不用管，就是提醒你这个文件之前没有而已。（一般警告没有那么多，我这里那么多是因为这个webpack是我自己的配置的，而且还有很多忽略文件没有写，所以这里报错特别多。一般来说做项目都是直接用脚手架帮我们自己创建好比较好。</strong><br><img src="./20190910142606889.png" alt="在这里插入图片描述"><br><strong>提交项目命令</strong></p><pre><code class="highlight nginx"><span class="attribute">git</span> commit -m “提交说明”</code></pre><p><strong>说明那里按照我的习惯就是修复bug，就是写修复什么什么bug，或者出现了什么问题没有解决先提交什么什么的。（执行这个命令后也会有少量警告，不用理会。除非是报错）</strong><br><img src="./20190910143534808.png" alt="在这里插入图片描述"><br><strong>这时候我们就可以执行提交命令了。</strong></p><pre><code class="highlight maxima">git <span class="built_in">push</span> <span class="built_in">origin</span> master</code></pre><p><strong>master这是默认的主分支，实际工作中一般会创建很多分支进行测试或者是调试，这里不详细说了。有空会写一篇详细的介绍。</strong><br><img src="./20190910143957279.png" alt="在这里插入图片描述"><br>上面命令行会多了 -u 这是我上传码云的时候，码云那边给的示例代码，具体上传到Github实际上只要我上面的写的命令行就行了。<br>这时候刷新我们之前的Github页面，就会出现有代码了。<br><img src="./20190910144236906.png" alt="在这里插入图片描述"><br>这个项目是我之前写的一个vue的qq音乐，因为之前提供接口的老朋友被腾讯爸爸警告了，所以我就没再维护用了。好了关于如何将代码上传到Github介绍到这里，码云的其实也差不多原理，而且码云在仓库创建好会给一些初始化命令提示，有兴趣的可以去了解一下，或者咨询一下我也行啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习mpvue的时候遇到了一些小问题（课程是慕课网上的Sam老师的一门课，非常推荐。）由于不知道老师什么时候回复我，而且为了方便起见，所以就想通过github代码管理来实现（其实之前是用过的，不过就随便用了一下，所以忘记了。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>vue刷新浏览器重定向到首页（或者某一个页面）</title>
    <link href="http://yoursite.com/2019/04/10/vue%E5%88%B7%E6%96%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E9%A6%96%E9%A1%B5%EF%BC%88%E6%88%96%E8%80%85%E6%9F%90%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%89/"/>
    <id>http://yoursite.com/2019/04/10/vue%E5%88%B7%E6%96%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E9%A6%96%E9%A1%B5%EF%BC%88%E6%88%96%E8%80%85%E6%9F%90%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%89/</id>
    <published>2019-04-10T13:53:32.000Z</published>
    <updated>2019-04-10T13:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近用vue写一个模仿qq音乐的单页面应用，<br>因为看到黄轶老师的例子是浏览器刷新会路由会重新定向到首页的，<br>所以就想应该是跟路由有关系的。</p><a id="more"></a><p>而且我注意到一个细节。就是我在其他的页面刷新的时候，它会先短暂显示首页，再跳到刷新之前的页面，<br>所以是不是可以理解为项目刷新会先经过首页，再到刷新之前的页面。<br>所以，我就在我的App.vue。写了下面的代码</p><pre><code class="highlight stylus"><span class="function"><span class="title">created</span><span class="params">()</span></span>&#123;         <span class="keyword">if</span>(this.<span class="variable">$router</span><span class="selector-class">.path</span> !== <span class="string">'/recommend'</span>)&#123;            this.<span class="variable">$router</span>.replace(<span class="string">'/recommend'</span>)        &#125;    &#125;</code></pre><p>注意这里的recommend是我项目重定向的首页，判断是不是首页，如果不是就用路由的方法replace，代替的意思。<br>换到首页。<br>这里给大家看一下，没做之前的效果。<br><img src="./20190410215128597.gif" alt="vue"><br>改完之后的效果：<br><img src="./20190410215621395.gif" alt="vue"><br>好了，写一个博文记录一下自己的小聪明，希望看到这个博文的你，有所启发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用vue写一个模仿qq音乐的单页面应用，&lt;br&gt;因为看到黄轶老师的例子是浏览器刷新会路由会重新定向到首页的，&lt;br&gt;所以就想应该是跟路由有关系的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Jquery中按钮事件重复绑定导致事件多次触发解决办法</title>
    <link href="http://yoursite.com/2018/09/21/Jquery%E4%B8%AD%E6%8C%89%E9%92%AE%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E7%BB%91%E5%AE%9A%E5%AF%BC%E8%87%B4%E4%BA%8B%E4%BB%B6%E5%A4%9A%E6%AC%A1%E8%A7%A6%E5%8F%91%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/21/Jquery%E4%B8%AD%E6%8C%89%E9%92%AE%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E7%BB%91%E5%AE%9A%E5%AF%BC%E8%87%B4%E4%BA%8B%E4%BB%B6%E5%A4%9A%E6%AC%A1%E8%A7%A6%E5%8F%91%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2018-09-21T06:46:00.000Z</published>
    <updated>2018-09-21T06:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在用jquery绑定事件的时候，一般来说习惯性都是喜欢绑定匿名事件。比如下面的</p><a id="more"></a><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"dv"</span> <span class="attr">value</span>=<span class="string">"按钮"</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-3.3.1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><span class="javascript">        $(<span class="string">".dv"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">// 第一种</span></span><span class="actionscript">            alert(<span class="string">"Hello World"</span>);</span>        &#125;);<span class="javascript">        $(<span class="string">".dv"</span>).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//第二种</span></span><span class="actionscript">            alert(<span class="string">"Hello World"</span>);</span>        &#125;);<span class="javascript">        $(<span class="string">".dv"</span>).bind(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//第三种</span></span><span class="actionscript">            alert(<span class="string">"Hello World"</span>);</span>        &#125;)    &#125;)<span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></code></pre><p>由于是匿名事件，所以假如你这个事件是放在<strong>一个for循环</strong>里面的话，这样的匿名事件是会重复的叠加叠加上去，<br>之所以会叠加，<strong>是因为是匿名事件，会重复的创建空间给这个匿名事件，所以才会导致叠加，这个问题可以后面解决。</strong></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>如果这个事件的挂载元素是一个动态创建的元素的话，就可以避免这样的事件叠加。就是说用的时候创建出来，不用的时候就删除掉这个元素，明显这样的方法会比较的麻烦，我个人也不推荐使用。</p><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>就是在绑定这个事件之前，我们先解绑之前绑定的事件，这样就可以保证每次操作的时候都是只有一个时间，具体的操作就是，如果用on绑定的事件，你就用off取消绑定，再用on绑定事件。代码如下</p><pre><code class="highlight applescript">$(<span class="string">".dv"</span>).off(<span class="string">"click"</span>).<span class="keyword">on</span><span class="params">(<span class="string">"click"</span>,function <span class="params">()</span> &#123; //第二种</span><span class="params">            alert<span class="params">(<span class="string">"Hello World"</span>)</span>;</span><span class="params">        &#125;)</span>;</code></pre><p>如果你用的是bind绑定的话就用unbind取消绑定，这样就可以避免使用匿名事件的时候事件会重复叠加到挂载元素中。</p><h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><p>就是使用one来绑定事件，这样绑定的事件只会触发一次，但是如果这个事件放在循环里面的话，还是会出现问题，这是我自己遇到过的错误，具体怎么绑定事件，代码如下：</p><pre><code class="highlight arcade">$(<span class="string">".dv"</span>).one(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="string">"Hello World"</span>);&#125;)</code></pre><p>最后一个办法就是从根本去解决，前面说到之所以会重复绑定到这个事件，是因为匿名函数，所以你可以把这个事件放到外面来，这样在循环的过程中，指针会一直指向这个已经创建的命名函数，不会重复创建空间。具体操作如下：</p><pre><code class="highlight arcade">$(<span class="string">".dv"</span>).on(<span class="string">"click"</span>,btn);              <span class="function"><span class="keyword">function</span> <span class="title">btn</span>(<span class="params"></span>) </span>&#123;           alert(<span class="string">"Hello World"</span>);       &#125;</code></pre><p>可能刚接触的萌新们会问，为什么btn后面不加括号。<strong>这里简单的说，如果加了括号就是调用这个函数的返回值，不加括号才是调用这个函数。只要这么记就没有问题了</strong>。好了，希望能帮助到正在学习开发的你。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用jquery绑定事件的时候，一般来说习惯性都是喜欢绑定匿名事件。比如下面的&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
  </entry>
  
</feed>

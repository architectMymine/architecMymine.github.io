<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RadiomM的博客世界</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-06T01:38:04.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>RadiomM</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vite+vue+elementplus安装过程遇到的问题</title>
    <link href="http://yoursite.com/2021/04/06/vite-vue-elementplus%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/04/06/vite-vue-elementplus%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-06T01:38:04.000Z</published>
    <updated>2021-04-06T01:38:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为最近忙的差不多了，而且vite据说用起来很快，所以正好现在有空闲时间，所以就来尝试一下配置一下vite+vue+elementPlus。<br><strong>注：本文主要是用yarn来安装包，用npm或者cnpm的同学相对应的切换即可。</strong></p><a id="more"></a><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>打开vite的官方文档，你会看到下面的图。<a href="https://cn.vitejs.dev/" target="_blank" rel="noopener">vite中文官网</a><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34729449662421cb394daf49fc3c30e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><pre><code class="highlight JavaScript">NPM：npm init @vitejs/appYARN：yarn create @vitejs/app</code></pre><p>心念念的直接使用<strong>yarn create @vitejs/app</strong>命令开始创建，结果报错了！<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cbc70c29d414d50ab33b3672c203cb0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>究其原因是因为yarn的安装包默认是在<strong>c盘的</strong>而我yarn安装在<strong>D盘的</strong>，说白了就是没有权限去创建下载包。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e84cfc6873f4421dbc84bc6b1588e42a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><pre><code class="highlight stata">yarn <span class="keyword">global</span> <span class="keyword">dir</span></code></pre><p>解决办法也很简单，就是将yarn的全局路径改一下到D盘就行了，在D盘创建<strong>yarn文件夹</strong>在文件下创建<strong>一个golbal和cache文件夹</strong>，现在我们就可以开始调整yarn的全局安装路径。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf4db9cd0d444b37b1833dbe1aed278a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><pre><code class="highlight routeros">yarn<span class="built_in"> config </span><span class="builtin-name">set</span> global-folder <span class="string">"D:\yarn\global"</span>yarn<span class="built_in"> config </span><span class="builtin-name">set</span> cache-folder <span class="string">"D:\yarn\cache"</span></code></pre><p>当然这个可以根据大家的安装的不同来改变。接着就可以开始用官方的命令了。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12df47d65c0e4894a61c4e3d4b2564f9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>选择你自己需要的模板，就可以了，至此一个步骤就完成了。<br>如果你是最早一批使用vue3的人，你会发现有新惊喜！<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/735875e928ee4e24aed79268fd5afdf3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>没错！这是之前提案要增加的东西，不用写setup函数，也不用导出变量！瞬间感觉好爽有没有。<a href="https://github.com/vuejs/rfcs/pull/182" target="_blank" rel="noopener">提案Github地址</a><br>在控制台也可以发现warning。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83b411f25b324c57af24c685ff490d73~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h2 id="配置element-plus"><a href="#配置element-plus" class="headerlink" title="配置element-plus"></a>配置element-plus</h2><p>配置其实可以参考<a href="https://element-plus.org/#/zh-CN/component/quickstart" target="_blank" rel="noopener">官网</a>来进行，但是众所周知官网的东西也会有不少的坑，所以我还是奉上我的踩坑提醒。</p><h4 id="一、安装element-plus"><a href="#一、安装element-plus" class="headerlink" title="一、安装element-plus"></a>一、安装element-plus</h4><pre><code class="highlight sql">NPM：npm <span class="keyword">install</span> <span class="keyword">element</span>-plus <span class="comment">--save</span>YARN：npm <span class="keyword">add</span> <span class="keyword">element</span>-plus</code></pre><p>接下来就是看你自己的需求了，分别可以进行全量引入或者是按需引入。</p><h4 id="二、全量引入"><a href="#二、全量引入" class="headerlink" title="二、全量引入"></a>二、全量引入</h4><p>你需要在main.js文件中写入以下内容：</p><pre><code class="highlight javascript"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span><span class="keyword">import</span> ElementPlus <span class="keyword">from</span> <span class="string">'element-plus'</span>;<span class="keyword">import</span> <span class="string">'element-plus/lib/theme-chalk/index.css'</span>;<span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;<span class="keyword">const</span> app = createApp(App)app.use(ElementPlus)app.mount(<span class="string">'#app'</span>)</code></pre><p>即可完成全量引入。</p><h4 id="三、按需引入"><a href="#三、按需引入" class="headerlink" title="三、按需引入"></a>三、按需引入</h4><p>都知道全量引入会导致项目过大，如果不是所有组件都使用的上的话，还是使用按需引入比较好。<strong>（注：本来主要讲的是vite，按需引入是vite的方式，cli的方式可以参照官网）</strong>，首先我们需要安装一个插件：** vite-plugin-style-import**</p><pre><code class="highlight armasm"><span class="symbol">yarn</span> <span class="keyword">add </span>vite-plugin-style-<span class="meta">import</span> -D</code></pre><p>因为element-plus提供<strong>Sass预编译</strong>的方式，接着我们需要在项目安装下面两个：</p><pre><code class="highlight dockerfile">yarn <span class="keyword">add</span><span class="bash"> sass sass-loader</span></code></pre><p>接着我们在 vite.config.js 文件修改成下面内容：</p><pre><code class="highlight javascript"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vite'</span><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">'@vitejs/plugin-vue'</span><span class="keyword">import</span> styleImport <span class="keyword">from</span> <span class="string">'vite-plugin-style-import'</span><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;  plugins: [    vue(),    styleImport(&#123;      libs: [&#123;        libraryName: <span class="string">'element-plus'</span>,        resolveStyle: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;          name = name.slice(<span class="number">3</span>)   <span class="comment">// 这里有个彩蛋，官网居然是用splice的，没错用的是数组方法。</span>          <span class="keyword">return</span> <span class="string">`element-plus/packages/theme-chalk/src/<span class="subst">$&#123;name&#125;</span>.scss`</span>;        &#125;,        resolveComponent: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;          <span class="keyword">return</span> <span class="string">`element-plus/lib/<span class="subst">$&#123;name&#125;</span>`</span>;        &#125;,      &#125;]    &#125;)  ]&#125;)</code></pre><p>同时，你需要在main.js中引入下面</p><pre><code class="highlight xl"><span class="keyword">import</span> 'element-plus/packages/<span class="built_in">theme</span>-chalk/src/base.scss'</code></pre><p>如果你项目不适用<strong>Sass</strong>的话，那就相对简单了，直接在vite.config.js修改为：</p><pre><code class="highlight javascript"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">'vite'</span><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">'@vitejs/plugin-vue'</span><span class="keyword">import</span> styleImport <span class="keyword">from</span> <span class="string">'vite-plugin-style-import'</span><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;  plugins: [    vue(),    styleImport(&#123;      libs: [        &#123;          libraryName: <span class="string">'element-plus'</span>,          resolveStyle: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;            <span class="keyword">return</span> <span class="string">`element-plus/lib/theme-chalk/<span class="subst">$&#123;name&#125;</span>.css`</span>;          &#125;,          resolveComponent: <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;            <span class="keyword">return</span> <span class="string">`element-plus/lib/<span class="subst">$&#123;name&#125;</span>`</span>;          &#125;,        &#125;      ]    &#125;)  ]&#125;)</code></pre><p><strong>不知道你有没有注意到，在Sass的方式引入需要将name切掉前三个的方式引入sass文件，其实直接去node_modules中查看相关目录可以发现，sass文件是没有以el-开头的，而css文件是以el-开头的，所以需要切掉前三个。</strong></p><p>然后我在src的目录下创建了一个文件夹叫<strong>plugins</strong>，在文件夹下创建了<strong>elementPlus.js</strong>文件，接着文件内容如下：</p><pre><code class="highlight autohotkey">import &#123;<span class="built_in">  ElAlert,</span><span class="built_in">  ElAside,</span><span class="built_in">  ElAutocomplete,</span><span class="built_in">  ElAvatar,</span><span class="built_in">  ElBacktop,</span><span class="built_in">  ElBadge,</span><span class="built_in">  ElBreadcrumb,</span><span class="built_in">  ElBreadcrumbItem,</span><span class="built_in">  ElButton,</span><span class="built_in">  ElButtonGroup,</span><span class="built_in">  ElCalendar,</span><span class="built_in">  ElCard,</span><span class="built_in">  ElCarousel,</span><span class="built_in">  ElCarouselItem,</span><span class="built_in">  ElCascader,</span><span class="built_in">  ElCascaderPanel,</span><span class="built_in">  ElCheckbox,</span><span class="built_in">  ElCheckboxButton,</span><span class="built_in">  ElCheckboxGroup,</span><span class="built_in">  ElCol,</span><span class="built_in">  ElCollapse,</span><span class="built_in">  ElCollapseItem,</span><span class="built_in">  ElCollapseTransition,</span><span class="built_in">  ElColorPicker,</span><span class="built_in">  ElContainer,</span><span class="built_in">  ElDatePicker,</span><span class="built_in">  ElDialog,</span><span class="built_in">  ElDivider,</span><span class="built_in">  ElDrawer,</span><span class="built_in">  ElDropdown,</span><span class="built_in">  ElDropdownItem,</span><span class="built_in">  ElDropdownMenu,</span><span class="built_in">  ElFooter,</span><span class="built_in">  ElForm,</span><span class="built_in">  ElFormItem,</span><span class="built_in">  ElHeader,</span><span class="built_in">  ElIcon,</span><span class="built_in">  ElImage,</span><span class="built_in">  ElInput,</span><span class="built_in">  ElInputNumber,</span><span class="built_in">  ElLink,</span><span class="built_in">  ElMain,</span><span class="built_in">  ElMenu,</span><span class="built_in">  ElMenuItem,</span><span class="built_in">  ElMenuItemGroup,</span><span class="built_in">  ElOption,</span><span class="built_in">  ElOptionGroup,</span><span class="built_in">  ElPageHeader,</span><span class="built_in">  ElPagination,</span><span class="built_in">  ElPopconfirm,</span><span class="built_in">  ElPopover,</span><span class="built_in">  ElPopper,</span><span class="built_in">  ElProgress,</span><span class="built_in">  ElRadio,</span><span class="built_in">  ElRadioButton,</span><span class="built_in">  ElRadioGroup,</span><span class="built_in">  ElRate,</span><span class="built_in">  ElRow,</span><span class="built_in">  ElScrollbar,</span><span class="built_in">  ElSelect,</span><span class="built_in">  ElSlider,</span><span class="built_in">  ElStep,</span><span class="built_in">  ElSteps,</span><span class="built_in">  ElSubmenu,</span><span class="built_in">  ElSwitch,</span><span class="built_in">  ElTabPane,</span><span class="built_in">  ElTable,</span><span class="built_in">  ElTableColumn,</span><span class="built_in">  ElTabs,</span><span class="built_in">  ElTag,</span><span class="built_in">  ElTimePicker,</span><span class="built_in">  ElTimeSelect,</span><span class="built_in">  ElTimeline,</span><span class="built_in">  ElTimelineItem,</span><span class="built_in">  ElTooltip,</span><span class="built_in">  ElTransfer,</span><span class="built_in">  ElTree,</span><span class="built_in">  ElUpload,</span><span class="built_in">  ElInfiniteScroll,</span><span class="built_in">  ElLoading,</span><span class="built_in">  ElMessage,</span><span class="built_in">  ElMessageBox,</span><span class="built_in">  ElNotification,</span>&#125; from 'element-plus'const components = [<span class="built_in">  ElAlert,</span><span class="built_in">  ElAside,</span><span class="built_in">  ElAutocomplete,</span><span class="built_in">  ElAvatar,</span><span class="built_in">  ElBacktop,</span><span class="built_in">  ElBadge,</span><span class="built_in">  ElBreadcrumb,</span><span class="built_in">  ElBreadcrumbItem,</span><span class="built_in">  ElButton,</span><span class="built_in">  ElButtonGroup,</span><span class="built_in">  ElCalendar,</span><span class="built_in">  ElCard,</span><span class="built_in">  ElCarousel,</span><span class="built_in">  ElCarouselItem,</span><span class="built_in">  ElCascader,</span><span class="built_in">  ElCascaderPanel,</span><span class="built_in">  ElCheckbox,</span><span class="built_in">  ElCheckboxButton,</span><span class="built_in">  ElCheckboxGroup,</span><span class="built_in">  ElCol,</span><span class="built_in">  ElCollapse,</span><span class="built_in">  ElCollapseItem,</span><span class="built_in">  ElCollapseTransition,</span><span class="built_in">  ElColorPicker,</span><span class="built_in">  ElContainer,</span><span class="built_in">  ElDatePicker,</span><span class="built_in">  ElDialog,</span><span class="built_in">  ElDivider,</span><span class="built_in">  ElDrawer,</span><span class="built_in">  ElDropdown,</span><span class="built_in">  ElDropdownItem,</span><span class="built_in">  ElDropdownMenu,</span><span class="built_in">  ElFooter,</span><span class="built_in">  ElForm,</span><span class="built_in">  ElFormItem,</span><span class="built_in">  ElHeader,</span><span class="built_in">  ElIcon,</span><span class="built_in">  ElImage,</span><span class="built_in">  ElInput,</span><span class="built_in">  ElInputNumber,</span><span class="built_in">  ElLink,</span><span class="built_in">  ElMain,</span><span class="built_in">  ElMenu,</span><span class="built_in">  ElMenuItem,</span><span class="built_in">  ElMenuItemGroup,</span><span class="built_in">  ElOption,</span><span class="built_in">  ElOptionGroup,</span><span class="built_in">  ElPageHeader,</span><span class="built_in">  ElPagination,</span><span class="built_in">  ElPopconfirm,</span><span class="built_in">  ElPopover,</span><span class="built_in">  ElPopper,</span><span class="built_in">  ElProgress,</span><span class="built_in">  ElRadio,</span><span class="built_in">  ElRadioButton,</span><span class="built_in">  ElRadioGroup,</span><span class="built_in">  ElRate,</span><span class="built_in">  ElRow,</span><span class="built_in">  ElScrollbar,</span><span class="built_in">  ElSelect,</span><span class="built_in">  ElSlider,</span><span class="built_in">  ElStep,</span><span class="built_in">  ElSteps,</span><span class="built_in">  ElSubmenu,</span><span class="built_in">  ElSwitch,</span><span class="built_in">  ElTabPane,</span><span class="built_in">  ElTable,</span><span class="built_in">  ElTableColumn,</span><span class="built_in">  ElTabs,</span><span class="built_in">  ElTag,</span><span class="built_in">  ElTimePicker,</span><span class="built_in">  ElTimeSelect,</span><span class="built_in">  ElTimeline,</span><span class="built_in">  ElTimelineItem,</span><span class="built_in">  ElTooltip,</span><span class="built_in">  ElTransfer,</span><span class="built_in">  ElTree,</span><span class="built_in">  ElUpload,</span>]const plugins = [<span class="built_in">  ElInfiniteScroll,</span><span class="built_in">  ElLoading,</span><span class="built_in">  ElMessage,</span><span class="built_in">  ElMessageBox,</span><span class="built_in">  ElNotification,</span>]<span class="title">const option = &#123; size: 'small', zIndex:</span> <span class="number">3000</span> &#125;export const useElementPlus = (app) =&gt; &#123;  // element全局配置  app.config.globalProperties.$ELEMENT = option  // 组件注册  components.forEach((component) =&gt; &#123;    app.component(component.name, component)  &#125;)  // 插件注册  plugins.forEach((plugin) =&gt; &#123;    app.use(plugin)  &#125;)&#125;</code></pre><p>注意，我这个文件其实全量引入的，自己按照自己的需求修改。同时值得说的是，在这个文件我导出了一个useElementPlus的方法。然后回到main.js中，内容如下：</p><pre><code class="highlight javascript"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span><span class="keyword">import</span> <span class="string">'element-plus/packages/theme-chalk/src/base.scss'</span><span class="keyword">import</span> &#123; useElementPlus &#125; <span class="keyword">from</span> <span class="string">'./plugins/elementPlus.js'</span><span class="keyword">const</span> app = createApp(App)useElementPlus(app)app.mount(<span class="string">'#app'</span>)</code></pre><p>应该不难理解，就是将vue实例放到useElementPlus方法中，然后在elementPlus文件中完成相关组件以及插件的注册。这样，我们的main.js文件会更加清晰。至此就完成了所有element-plus的配置。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>后面会完善加入<strong>vuex</strong>和<strong>vue-router</strong>。本文的完整配置将放在<a href="https://gitee.com/radiomm/vue-vite-element-plus" target="_blank" rel="noopener">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为最近忙的差不多了，而且vite据说用起来很快，所以正好现在有空闲时间，所以就来尝试一下配置一下vite+vue+elementPlus。&lt;br&gt;&lt;strong&gt;注：本文主要是用yarn来安装包，用npm或者cnpm的同学相对应的切换即可。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="那些烦人的项目搭建" scheme="http://yoursite.com/tags/%E9%82%A3%E4%BA%9B%E7%83%A6%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>upload组件的妙用</title>
    <link href="http://yoursite.com/2020/12/14/upload%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A6%99%E7%94%A8/"/>
    <id>http://yoursite.com/2020/12/14/upload%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A6%99%E7%94%A8/</id>
    <published>2020-12-13T16:00:00.000Z</published>
    <updated>2020-12-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>其实说多了也只是泪，按照本来的我正常的逻辑都是这样的：用upload组件，选择图片的时候就会立刻上传到指定的地址，最多也就配置一下header，再大不了就手写限制一下文件的大小。<br>但是我这边的需求是这样的：<strong>上传的时候用的是文件流，就是直接把文件流赋值给参数，然后回显的时候后端会返回一个图片的id，我通过拼接地址的方式去显示图片</strong>。</p><a id="more"></a><p>我第一时间的心情的这样的：</p><p><img src="https://img-blog.csdnimg.cn/20201214155619944.gif#pic" alt="在这里插入图片描述"></p><p>但是没办法啊，后端他们不打算改，只能前端苦逼的寻找问题的解决办法。经过多次的尝试(掉了很多的头发），终于发现了如何去处理这个问题了。下面介绍主角：<br><img src="https://img-blog.csdnimg.cn/20201214155928214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="上传图片使用文件流形式"><a href="#上传图片使用文件流形式" class="headerlink" title="上传图片使用文件流形式"></a>上传图片使用文件流形式</h2><p>下面的代码参考：</p><pre><code class="highlight applescript">&lt;el-upload  <span class="built_in">class</span>=<span class="string">"avatar-uploader"</span>  action=<span class="string">"#"</span>  <span class="built_in">list</span>-type=<span class="string">"picture-card"</span>  :<span class="built_in">file</span>-<span class="built_in">list</span>=<span class="string">"form.codeArray"</span>  :limit=<span class="string">"1"</span>  accept=<span class="string">"image/jpg, image/jpeg,image/png"</span>  :auto-upload=<span class="string">"false"</span>  :<span class="keyword">on</span>-exceed=<span class="string">"handleExceed"</span>  :<span class="keyword">on</span>-change=<span class="string">"handleChange"</span>  :<span class="keyword">on</span>-remove=<span class="string">"handleRemove"</span>&gt;  &lt;i <span class="built_in">class</span>=<span class="string">"el-icon-plus"</span>&gt;&lt;/i&gt;  &lt;<span class="keyword">div</span> slot=<span class="string">"tip"</span> <span class="built_in">class</span>=<span class="string">"el-upload__tip"</span>&gt;    建议上传<span class="number">1</span>:<span class="number">1</span>尺寸图片，避免显示不全    &lt;strong style=<span class="string">"color: red"</span>&gt;(只能上传一张图片)&lt;/strong&gt;  &lt;/<span class="keyword">div</span>&gt;&lt;/el-upload&gt;</code></pre><p>参数不做说明，详情可以参考<a href="https://element.eleme.cn/#/zh-CN/component/upload" target="_blank" rel="noopener">这里</a>。<br>将<strong>auto-upload</strong>设置为false的时候，你会发现你之前使用的钩子很多都没有用，唯独有一个钩子会触发的，可以让你获取到文件的，那就是<strong>on-change</strong>事件。来看看官方文档的介绍：<br><img src="https://img-blog.csdnimg.cn/20201214160739849.png#pic_center" alt="在这里插入图片描述"><br>当我们添加图片的时候onchange事件会有下面的输出<br><img src="https://img-blog.csdnimg.cn/20201214161021678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>还记的我的需求吗？没错，就是上传的时候把文件流赋值给参数，上面参数中<strong>raw</strong>就是我们需要的，我们只要把这些东西给赋值变量就可以了。</p><h2 id="回显使用图片地址"><a href="#回显使用图片地址" class="headerlink" title="回显使用图片地址"></a>回显使用图片地址</h2><p>回显的时候就相对简单了，就是直接按照官网的格式放进去数组就完事了</p><pre><code class="highlight css">&#123;   <span class="attribute">title</span>: <span class="string">'aaa'</span>,   url: <span class="string">'aaa.jpg'</span> &#125;</code></pre><p>移除的时候就相对应的是用on-remove的事件去移除数组中的元素就可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体的步骤不算难，难点就可能是在发现的过程吧，第一就是这个<strong>auto-upload</strong>，文档中只是简单的说不会立即上传，但是说明实际有什么用途，再就是设置这个属性值为false的时候会触发那些钩子也没有说明，最后是我一个个钩子的去尝试，查看有什么使用区别。（当然你也可以说博主的理解能力差吧，这个我不会否认的。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实说多了也只是泪，按照本来的我正常的逻辑都是这样的：用upload组件，选择图片的时候就会立刻上传到指定的地址，最多也就配置一下header，再大不了就手写限制一下文件的大小。&lt;br&gt;但是我这边的需求是这样的：&lt;strong&gt;上传的时候用的是文件流，就是直接把文件流赋值给参数，然后回显的时候后端会返回一个图片的id，我通过拼接地址的方式去显示图片&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="那些讨人厌的需求" scheme="http://yoursite.com/tags/%E9%82%A3%E4%BA%9B%E8%AE%A8%E4%BA%BA%E5%8E%8C%E7%9A%84%E9%9C%80%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>使用vueCli4.0配置eslint+prettier</title>
    <link href="http://yoursite.com/2020/12/08/%E4%BD%BF%E7%94%A8vueCli4-0%E9%85%8D%E7%BD%AEeslint-prettier/"/>
    <id>http://yoursite.com/2020/12/08/%E4%BD%BF%E7%94%A8vueCli4-0%E9%85%8D%E7%BD%AEeslint-prettier/</id>
    <published>2020-12-07T16:00:00.000Z</published>
    <updated>2020-12-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>众所周知eslint只是个语法检查工具，要想做到真正的自动修改语法错误，还要考prettier。下面介绍两种方式，可以在VScode工具里使用。首先，所有的前提是你的vscode已经安装了prettier插件，而且我建议你开启保存时自动调整代码，文章最后附上。</p><a id="more"></a><p>下面步骤用图片代替：<br><img src="https://img-blog.csdnimg.cn/20201208164904967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201208164915225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201208164928119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201208164937174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201208164948805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>然后接下来的步骤两个可选项：</strong></p><h4 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h4><p><img src="https://img-blog.csdnimg.cn/20201208165118393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h4><p><img src="https://img-blog.csdnimg.cn/2020120816513294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201208165146867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202012081651556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201208165201877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>好了，现在使用vuecli4.0生成的vue就成功了。<br>直接用VScode打开项目，然后在主目录添加这样这个文件：prettier.config.js。<br><img src="https://img-blog.csdnimg.cn/20201208165425547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>文件的内容主要如下：</p><pre><code class="highlight yaml"><span class="string">module.exports</span> <span class="string">=</span> <span class="string">&#123;</span>  <span class="attr">printWidth:</span> <span class="number">80</span><span class="string">,</span>  <span class="attr">tabWidth:</span> <span class="number">2</span><span class="string">,</span>  <span class="attr">useTabs:</span> <span class="literal">false</span><span class="string">,</span>  <span class="attr">semi:</span> <span class="literal">false</span><span class="string">,</span> <span class="string">//</span> <span class="string">末尾不加尾号</span>  <span class="attr">singleQuote:</span> <span class="literal">true</span><span class="string">,</span> <span class="string">//</span> <span class="string">默认单引号</span>  <span class="attr">quoteProps:</span> <span class="string">'as-needed'</span><span class="string">,</span>  <span class="attr">jsxSingleQuote:</span> <span class="literal">false</span><span class="string">,</span>  <span class="attr">trailingComma:</span> <span class="string">'none'</span><span class="string">,</span> <span class="string">//</span> <span class="string">es5对象属性最后加逗号。none不加</span>  <span class="attr">bracketSpacing:</span> <span class="literal">true</span><span class="string">,</span>  <span class="attr">jsxBracketSameLine:</span> <span class="literal">false</span><span class="string">,</span>  <span class="attr">arrowParens:</span> <span class="string">'always'</span><span class="string">,</span>  <span class="attr">htmlWhitespaceSensitivity:</span> <span class="string">'ignore'</span><span class="string">,</span>  <span class="attr">vueIndentScriptAndStyle:</span> <span class="literal">false</span><span class="string">,</span> <span class="string">//</span> <span class="string">script、style标签不缩进</span>  <span class="attr">endOfLine:</span> <span class="string">'lf'</span><span class="string">,</span><span class="string">&#125;</span></code></pre><p>当然这样还没行，在.eslintrc.js文件要多一个规则：<br><img src="https://img-blog.csdnimg.cn/20201208165646350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里是代码：</p><pre><code class="highlight scheme"><span class="symbol">'space-before-function-paren</span><span class="symbol">':</span> <span class="symbol">'off</span>'</code></pre><p>至此，项目就配置完成了。运行npm run serve可以项目正常运行。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>如何在VScode开启prettier保存时运行呢？下面是步骤：<br>打开设置-&gt;搜索save<br><img src="https://img-blog.csdnimg.cn/20201208170426609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>如果项目实际开发过程中有哪些eslint的报错，直接在文件中关闭即可。如果有问题可以在下面提问，一般的问题博主<strong>大概可能应该可以</strong>回答。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知eslint只是个语法检查工具，要想做到真正的自动修改语法错误，还要考prettier。下面介绍两种方式，可以在VScode工具里使用。首先，所有的前提是你的vscode已经安装了prettier插件，而且我建议你开启保存时自动调整代码，文章最后附上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="那些烦人的项目搭建" scheme="http://yoursite.com/tags/%E9%82%A3%E4%BA%9B%E7%83%A6%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>安卓、ios微信H5分享踩坑指南</title>
    <link href="http://yoursite.com/2020/12/07/%E5%AE%89%E5%8D%93%E3%80%81ios%E5%BE%AE%E4%BF%A1H5%E5%88%86%E4%BA%AB%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2020/12/07/%E5%AE%89%E5%8D%93%E3%80%81ios%E5%BE%AE%E4%BF%A1H5%E5%88%86%E4%BA%AB%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</id>
    <published>2020-12-07T09:31:25.000Z</published>
    <updated>2020-12-07T09:31:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>博主最近在开发一个H5的项目，正好遇到了微信分享，不得不说微信的文档不知多久没更新的缘故，里面的操作可以在安卓完美的进行，但是！有一个可恶的苹果挡住了去路！闲话不多说，直接进去正题。附上步骤图</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201207111101984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="步骤1"></p><h2 id="一、判断是否需要微信授权"><a href="#一、判断是否需要微信授权" class="headerlink" title="一、判断是否需要微信授权"></a>一、判断是否需要微信授权</h2><p>根据<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#2" target="_blank" rel="noopener">微信JSSDK文档</a>，一般来说后端需要配置白名单。进入公众号里面填写JS接口安全域名，这点很重要，因为这样才能获取到正确的config配置。按照我现在的项目，我们前端主要做的就是判断用户有没有openid，没有的话就让他去微信登录授权。那该怎么判断呢？没错只能在地址里判断有没有code码，没有code码的时候，我们就让他去进行微信授权。</p><pre><code class="highlight stylus"><span class="function"><span class="title">if</span><span class="params">(window.location.href.includes(<span class="string">'code='</span>)</span></span>&#123; <span class="comment">// 有code码的时候进行的操作</span>&#125; <span class="keyword">else</span>&#123;<span class="comment">// 没有code码时候要进行微信授权</span>&#125;</code></pre><p>如果你是用vue的hash模式开发的话，当你用微信开发者工具看到微信正确授权回来之后是这样的一个链接。</p><pre><code class="highlight pf">http://<span class="number">192.168</span>.<span class="number">1.165</span>/?code=<span class="number">051</span>JpHFa1U8B6A0sfLIa1m5d422JpHFy&amp;<span class="keyword">state</span>=<span class="comment">#/activity</span></code></pre><p>悲剧不？难受不？这样的code码要自己在链接里获取(<strong>开发环境下是不会跳转到你本地的，上面的代码只是展示用，实际上微信只会跳转到你的线上域名地址</strong>）。那要怎么获取啊？贴心博主给你下面的代码，不求人！</p><pre><code class="highlight javascript"><span class="comment">/**</span><span class="comment"> * <span class="doctag">@description </span>解析get参数</span><span class="comment"> * <span class="doctag">@param <span class="variable">url</span></span></span><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Object&#125;</span></span></span><span class="comment"> */</span><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getUrlParams</span> (<span class="params">url</span>) </span>&#123;  <span class="keyword">if</span> (url.includes(<span class="string">'?'</span>)) &#123;    <span class="keyword">const</span> str = url.split(<span class="string">'?'</span>)[<span class="number">1</span>].split(<span class="string">'#'</span>)[<span class="number">0</span>]    <span class="keyword">const</span> arr = str.split(<span class="string">'&amp;'</span>)    <span class="keyword">const</span> obj = &#123;&#125;    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;      obj[arr[i].split(<span class="string">'='</span>)[<span class="number">0</span>]] = arr[i].split(<span class="string">'='</span>)[<span class="number">1</span>]    &#125;    <span class="keyword">return</span> obj  &#125; <span class="keyword">else</span> &#123;    <span class="keyword">return</span> &#123;&#125;  &#125;&#125;</code></pre><p>只要你把上面的一整个链接直接放到这个方法里面，他就会返回一个Object对象给你。用上面的链接的话返回的就是下面的。</p><pre><code class="highlight pf">const obj = &#123;code:<span class="number">051</span>JpHFa1U8B6A0sfLIa1m5d422JpHFy,<span class="keyword">state</span>:<span class="string">""</span>&#125;</code></pre><p>这时候你只需要将code码发送给你的后端，让他返回给你openid就可以了。<strong>当然这个方法不止是这么用的，当你分享需要带参数的时候，这个方法就可以放在跳转到微信授权之前直接调用，然后你就把传过来的参数直接保存到本地储存。为什么要这么做？没错，微信会把你的链接截取的不成人样，所以只能这样保存参数了。</strong></p><h2 id="二、获取config配置以及如何携带参数"><a href="#二、获取config配置以及如何携带参数" class="headerlink" title="二、获取config配置以及如何携带参数"></a>二、获取config配置以及如何携带参数</h2><p>这里如何引入微信的JSSDK就不再说了，可以通过npm下载包或者是script标签引入。如下：</p><pre><code class="highlight coffeescript"><span class="built_in">npm</span> i -S weixin-js-sdk</code></pre><p>又或者</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://res.wx.qq.com/open/js/jweixin-1.6.0.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    vue项目的话请写在index.html页面</code></pre><h4 id="2-1-config配置注入"><a href="#2-1-config配置注入" class="headerlink" title="2.1  config配置注入"></a>2.1  config配置注入</h4><p>那么我们就进行第三步！就是config配置注入。原理就是我们通过接口给后端传递<strong>url</strong>地址(<strong>必须与上面公众号配置的安全域名一致！</strong>)，后端通过微信的接口获取到config配置，具体为什么这么做呢？就是为了安全，不泄露你的公众号的某些信息。然后我们就填到下面的方法。</p><pre><code class="highlight less"><span class="selector-tag">wx</span><span class="selector-class">.config</span>(&#123;  <span class="attribute">debug</span>: true, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span>  <span class="attribute">appId</span>: <span class="string">''</span>, <span class="comment">// 必填，公众号的唯一标识</span>  <span class="attribute">timestamp</span>: , <span class="comment">// 必填，生成签名的时间戳</span>  <span class="attribute">nonceStr</span>: <span class="string">''</span>, <span class="comment">// 必填，生成签名的随机串</span>  <span class="attribute">signature</span>: <span class="string">''</span>,<span class="comment">// 必填，签名</span>  <span class="attribute">jsApiList</span>: [<span class="string">'updateTimelineShareData'</span>, <span class="string">'updateAppMessageShareData'</span>] <span class="comment">// 必填，需要使用的JS接口列表</span>&#125;);</code></pre><p>这里我需要的是微信好友分享以及微信朋友圈分享，更多的接口可以查询<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#10" target="_blank" rel="noopener">微信接口文档</a>。<strong>这是需要特别提醒的是，配置成功后直接调用wx.ready事件</strong><br><img src="https://img-blog.csdnimg.cn/20201207111033878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>一般调试的时候都会打开debug。就是config里面的那个，方便查看config配置成功与否。</p><h4 id="2-2-分享链接带参数"><a href="#2-2-分享链接带参数" class="headerlink" title="2.2 分享链接带参数"></a>2.2 分享链接带参数</h4><p>如果是简单的分享网页的话，其实不需要做这些步骤。因为微信内置就可以分享网页，只是不会携带任何东西而已，如果是绑定上下级关系的时候，就需要用到自定义分享去配置。前面说到的<strong>getUrlParams</strong>方法就起了重大作用，用来保存携带过来的参数，那么参数我们需要怎么拼接呢？首先有一点需要明确的是，微信授权回来以后，你的网址链接一般都是长这样的：</p><pre><code class="highlight pf">http://<span class="number">192.168</span>.<span class="number">1.153</span>/?code=<span class="number">051</span>JpHFa1U8B6A0sfLIa1m5d422JpHFy&amp;<span class="keyword">state</span>=<span class="comment">#/invite</span></code></pre><p>没错，会一直携带微信授权回来的东西(博主用的是vue的hash模式，默认将路由地址加在后面)，那么我们需要拼接出来的地址是怎么样的？如下：</p><pre><code class="highlight dts"><span class="symbol">http:</span><span class="comment">//192.168.1.153/?spoorerid=100&amp;inviteuserid=1144</span></code></pre><p>没错，微信的官方文档中，特别提醒了<strong>我们的链接不能携带#号后面的东西</strong>。详情请看<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#66" target="_blank" rel="noopener">这里</a><br><img src="https://img-blog.csdnimg.cn/20201207112249794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU5MjI5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>明确标签可以通过？的get方式携带参数，那么我们只要配置成这样就完事了。直接如何配置不做任何示例，我的方法就是，用一个变量拼接参数。如拼接成 <strong>?spoorerid=100&amp;inviteuserid=1144</strong>，然后拼成一个完整的链接。如下：</p><pre><code class="highlight pgsql">const link = (<span class="keyword">window</span>.<span class="keyword">location</span>.href).replace(<span class="keyword">window</span>.<span class="keyword">location</span>.<span class="keyword">search</span>, addlink).split(<span class="string">'#'</span>)[<span class="number">0</span>]// 其中addlink就是上面说的变量。拼出来的结果在上面已经展示了。</code></pre><h2 id="三、分享操作"><a href="#三、分享操作" class="headerlink" title="三、分享操作"></a>三、分享操作</h2><p>基本上做完上面的工作就可以去分享了，但是！众所周知，ios跟安卓一直有这微妙的关系！没错，如果你是像博主一样，点击了分享以后，才去获取config配置的话，那么恭喜你，安卓是可以的，但是ios的就是不行！不管是在微信开发者工具多少次的成功，你ios这样做就是不行。下面提供两种方法。</p><h4 id="3-1-全局配置"><a href="#3-1-全局配置" class="headerlink" title="3.1 全局配置"></a>3.1 全局配置</h4><p>实现起来很简单，就是直接在app.vue里把微信JSSDK的东西都写上，包括获取config配置，还有就是ready里面的东西都写上，直接在mounted调用一下就可以了。但是这样的弊端就是，假如需求是指定某个页面才能分享操作，这样写的话就会单页面里的任何一个页面都可以分享，这是我们不想要的。</p><h4 id="3-2-独立配置-指定某个页面分享"><a href="#3-2-独立配置-指定某个页面分享" class="headerlink" title="3.2 独立配置(指定某个页面分享)"></a>3.2 独立配置(指定某个页面分享)</h4><p>上面说到，如果点击触发事件的时候才去获取config配置等等，在ios是不行的。经过不断的尝试以及是查询(其实是问了某个高手)，当你跳转到那个需要分享的页面时，你不能使用<strong>this.$router.push()</strong>的方式去跳转，在hash模式下，其实页面是不做任何跳转的，这就导致了在ios中不能获取到配置项。这时候，原生的东西就起了关键作用：</p><pre><code class="highlight pgsql"><span class="keyword">window</span>.<span class="keyword">location</span>.href = <span class="keyword">window</span>.<span class="keyword">location</span>.href.split(<span class="string">'#'</span>)[<span class="number">0</span>] + <span class="string">'#/invite'</span></code></pre><p>通过下面的方式跳转到分享页，页面是相当于刷新了一次，这时候在ios就能获取到相关配置了。可以参考<a href="https://www.cnblogs.com/dream111/p/13520017.html" target="_blank" rel="noopener">这个文章</a>。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="highlight javascript"><span class="keyword">import</span> wx <span class="keyword">from</span> <span class="string">'weixin-js-sdk'</span><span class="keyword">import</span> &#123; getWxConfig &#125; <span class="keyword">from</span> <span class="string">'../api/user'</span><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">wxShare</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">const</span> params = &#123;    type: <span class="number">1</span>,    url: <span class="built_in">window</span>.location.href.split(<span class="string">'#'</span>)[<span class="number">0</span>]  &#125;  <span class="comment">// let link = (window.location.href).replace(window.location.search, '').split('#')[0]</span>  <span class="keyword">let</span> addlink = <span class="string">''</span>  <span class="keyword">const</span> query = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'firstQuery'</span>))  <span class="keyword">const</span> user = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'User-Info'</span>))  <span class="keyword">const</span> counselor = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'counselor'</span>))  <span class="keyword">if</span> (query.spoorerid) &#123;    addlink += <span class="string">`?spoorerid=<span class="subst">$&#123;query.spoorerid&#125;</span>`</span>    <span class="keyword">if</span> (user &amp;&amp; user.id) &#123;      addlink += <span class="string">`&amp;inviteuserid=<span class="subst">$&#123;user.id&#125;</span>`</span>    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (query.inviteuserid) &#123;      addlink += <span class="string">`&amp;inviteuserid=<span class="subst">$&#123;query.inviteuserid&#125;</span>`</span>    &#125; <span class="keyword">else</span> &#123;      addlink += <span class="string">'&amp;inviteuserid=0'</span>    &#125;  &#125; <span class="keyword">else</span> &#123;    addlink += <span class="string">`?spoorerid=<span class="subst">$&#123;counselor.id&#125;</span>`</span>    <span class="keyword">if</span> (user &amp;&amp; user.id) &#123;      addlink += <span class="string">`&amp;inviteuserid=<span class="subst">$&#123;user.id&#125;</span>`</span>    &#125;  &#125;  <span class="keyword">const</span> link = (<span class="built_in">window</span>.location.href).replace(<span class="built_in">window</span>.location.search, addlink).split(<span class="string">'#'</span>)[<span class="number">0</span>]  <span class="comment">// console.log('addlink', addlink)</span>  <span class="comment">// console.log('link', link)</span>  getWxConfig(params).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;    <span class="keyword">if</span> (res.code === <span class="number">200</span>) &#123;      wx.config(&#123;        debug: <span class="literal">false</span>,        appId: res.data.appid,        timestamp: res.data.timestamp,        nonceStr: res.data.nonceStr,        signature: res.data.signature,        jsApiList: [<span class="string">'updateTimelineShareData'</span>, <span class="string">'updateAppMessageShareData'</span>]      &#125;)    &#125;  &#125;)  wx.ready(<span class="function"><span class="params">()</span> =&gt;</span> &#123;    <span class="keyword">const</span> shareObj = &#123;      title: <span class="string">'*******'</span>,      link: link,      imgUrl: <span class="string">'http://hteshb.beegoedu.com/share.png'</span>,      desc: <span class="string">'你也一起来跟我携手上进吧'</span>,      success() &#123;        <span class="built_in">console</span>.log(<span class="string">'分享成功'</span>)      &#125;,      fail() &#123;        <span class="built_in">console</span>.log(<span class="string">'分享失败'</span>)      &#125;    &#125;    <span class="comment">// 分享给朋友</span>    wx.updateAppMessageShareData(shareObj)    <span class="comment">// 分享到朋友圈</span>    wx.updateTimelineShareData(shareObj)  &#125;)  wx.error(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;    <span class="comment">// config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。</span>    <span class="built_in">console</span>.log(<span class="string">'失败返回参数'</span>, res)  &#125;)&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，花了两三个小时终于是整理完了这文章。如果觉得有用，喜欢收藏或者点个喜欢，毕竟这是博主搜了一个多星期百度的结果，希望能帮到大家永不加班，到点就走！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博主最近在开发一个H5的项目，正好遇到了微信分享，不得不说微信的文档不知多久没更新的缘故，里面的操作可以在安卓完美的进行，但是！有一个可恶的苹果挡住了去路！闲话不多说，直接进去正题。附上步骤图&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Wx生态的那些事" scheme="http://yoursite.com/tags/Wx%E7%94%9F%E6%80%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>canvas压缩图片</title>
    <link href="http://yoursite.com/2020/06/11/canvas%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2020/06/11/canvas%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</id>
    <published>2020-06-11T00:37:40.000Z</published>
    <updated>2020-06-11T00:37:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>article p{    font-size:16px;    line-height:28px;}</style><p>&emsp; &emsp; 最近发现了一个可以利用canvas压缩图片的方法，于是乎我就自己尝试了一下，发现效果还是不错的，可以控制压缩的输出格式，还有压缩比例。为什么会发现这个东西呢，因为我最近研究东西的时候突然想到一个需求，那就是我们前端能不能在上传图片之前压缩一下图片，于是乎就有一系列的操作了。原理呢就是利用了canvas的api以及浏览器提供的FileReader和Image的两个对象。老规矩，先把歌安排上。</p><a id="more"></a>    <div id="aplayer-UwNuzSfJ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="476081899" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>既然是图片压缩无可避免的就是对格式以及文件大小的限制，看下面代码:</p><pre><code class="highlight actionscript"><span class="keyword">const</span> ACCEPT = [<span class="string">'image/jpg'</span>, <span class="string">'image/png'</span>, <span class="string">'image/jpeg'</span>]  <span class="comment">// 格式判断数组</span><span class="keyword">const</span> MAXSIZE = <span class="number">3</span> * <span class="number">1024</span> * <span class="number">1024</span>                          <span class="comment">// 限制文件大小，这里是3MB</span></code></pre><p>既然是上传的时候对文件的压缩，那么就少不了下面的代码了：</p><pre><code class="highlight routeros">&lt;input <span class="attribute">type</span>=<span class="string">"file"</span> <span class="attribute">id</span>=<span class="string">"upload"</span>&gt;</code></pre><p>那么我们现在要做的就是去获取文件，对文件的类型以及大小做出判断。如何获取文件？看下面代码：</p><pre><code class="highlight javascript"><span class="keyword">const</span> upload = <span class="built_in">document</span>.getElementById(<span class="string">'upload'</span>)upload.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;    <span class="comment">//console.log(e.target.files);</span>    <span class="keyword">const</span> [file] = e.target.files     <span class="comment">//获取文件</span>    <span class="comment">// 如果没有文件我们就直接返回</span>    <span class="keyword">if</span> (!file) &#123;        <span class="keyword">return</span>    &#125;    <span class="comment">// 对属性重命名</span>    <span class="keyword">const</span> &#123; <span class="attr">type</span>: fileType, <span class="attr">size</span>: fileSize &#125; = file    <span class="comment">// 判断文件类型</span>    <span class="keyword">if</span> (!ACCEPT.includes(fileType)) &#123;        alert(<span class="string">`不支持[ <span class="subst">$&#123;fileTypez&#125;</span> ]文件类型!`</span>)        upload.value = <span class="string">''</span>        <span class="keyword">return</span>    &#125;    <span class="comment">// 判断文件大小</span>    <span class="keyword">if</span> (fileSize &gt; MAXSIZE) &#123;        alert(<span class="string">`文件超出 <span class="subst">$&#123;MAXSIZE_STR&#125;</span>`</span>)        upload.value = <span class="string">''</span>        <span class="keyword">return</span>    &#125;&#125;)</code></pre><p>放开console.log(e.target.file)可以看看浏览器是输出什么内容<br><img src="./canvas1.png" alt="canvas1"></p><p>我们运用了ES6里面的数组结构方法，获取到了file文件，并对里面的属性进行了重新命名<strong>(注意，重新命名之后原来名字就找不到了)</strong>，重新命名主要是为了代码的可读性。毕竟直接写他原本的属性判断，我估计没几个人可以一眼看代码就知道怎么回事的。</p><p>但是这里只是对文件的大小以及格式的判断，我们需要将图片转成Base64的格式。</p><pre><code class="highlight reasonml"><span class="comment">// 将图片转成Base64的格式</span><span class="keyword">function</span> convert<span class="constructor">ImageToBase64(<span class="params">file</span>, <span class="params">callback</span>)</span> &#123;    <span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="constructor">FileReader()</span>    reader.read<span class="constructor">AsDataURL(<span class="params">file</span>)</span>    reader.add<span class="constructor">EventListener('<span class="params">load</span>', <span class="params">function</span> (<span class="params">e</span>)</span> &#123;        const base64Image = e.target.result        callback<span class="operator"> &amp;&amp; </span>callback(base64Image)        <span class="comment">//回收内存</span>        reader = null    &#125;)&#125;</code></pre><p>可以看到我们首先利用FileReader将图片转成了Base64，并利用load事件，在图片加载完之后我们就调用了回调函数，同时我们对利用完的FileReader进行了手动的垃圾回收。为了方便你们的理解，我提供了MDN上对web api 中的FileReader的解释。</p><blockquote><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。<br>其中File对象可以是来自用户在一个input元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。<br>重要提示： FileReader仅用于以安全的方式从用户（远程）系统读取文件内容 它不能用于从文件系统中按路径名简单地读取文件。 要在JavaScript中按路径名读取文件，应使用标准Ajax解决方案进行服务器端文件读取，如果读取跨域，则使用CORS权限。</p></blockquote><p>前期工作做的差不多了，我们基本可以进入压缩图片的核心工作了，在这之前有有件重要的事情要干，那就是调用convertImageToBase64函数。</p><pre><code class="highlight reasonml">convert<span class="constructor">ImageToBase64(<span class="params">file</span>, <span class="params">compress</span>)</span></code></pre><p>其中compress就是我们要实现图片压缩的方法了，可以分成两步实现。先上第一步代码</p><pre><code class="highlight processing">let maxW = <span class="number">1024</span>  <span class="comment">//压缩的图片宽度</span>let maxH = <span class="number">1024</span>  <span class="comment">//压缩的图片高度</span><span class="keyword">const</span> <span class="built_in">image</span> = <span class="keyword">new</span> Image()<span class="built_in">image</span>.src = base64Image<span class="built_in">image</span>.addEventListener(<span class="string">'load'</span>, function (e) &#123;    let radio  <span class="comment">// 图片压缩比</span>    let needCompress = <span class="keyword">false</span>   <span class="comment">//是否需要压缩</span>    <span class="keyword">if</span> (maxW &lt; <span class="built_in">image</span>.naturalWidth) &#123;        needCompress = <span class="keyword">true</span>        radio = <span class="built_in">image</span>.naturalWidth / maxW        maxH = <span class="built_in">image</span>.naturalHeight / radio    &#125;    <span class="keyword">if</span> (maxH &lt; <span class="built_in">image</span>.naturalHeight) &#123;        needCompress = <span class="keyword">true</span>        radio = <span class="built_in">image</span>.naturalHeight / maxH        maxW = <span class="built_in">image</span>.naturalWidth / radio    &#125;    <span class="keyword">if</span> (!needCompress) &#123;        maxW = <span class="built_in">image</span>.naturalWidth        maxH = <span class="built_in">image</span>.naturalHeight    &#125;&#125;)document.body.appendChild(<span class="built_in">image</span>)</code></pre><p>这里主要是对图片压缩比的计算，而且是要对高度以及宽度的计算，判断是否需要压缩。需要注意的是如果不需要压缩的时候，实际的宽高，就是图片本身的宽高,需要压缩的时候，宽高需要压缩到一样的比例。那么下面我们就可以运用canvas，将图片绘制出来。</p><pre><code class="highlight reasonml">const canvas = document.create<span class="constructor">Element('<span class="params">canvas</span>')</span>canvas.set<span class="constructor">Attribute('<span class="params">id</span>', '<span class="params">__compress__</span>)</span>')canvas.width = maxWcanvas.height = maxHcanvas.style.visibility = 'visible'document.body.append<span class="constructor">Child(<span class="params">canvas</span>)</span> const ctx = canvas.get<span class="constructor">Context('2d')</span>ctx.clear<span class="constructor">Rect(0, 0, <span class="params">maxW</span>, <span class="params">maxH</span>)</span>ctx.draw<span class="constructor">Image(<span class="params">image</span>, 0, 0, <span class="params">maxW</span>, <span class="params">maxH</span>)</span>const compressImage = canvas.<span class="keyword">to</span><span class="constructor">DataURL('<span class="params">image</span><span class="operator">/</span><span class="params">jpg</span>', 0.9)</span>  <span class="comment">//控制输出的Base64图片的格式以及压缩率</span>canvas.remove<span class="literal">()</span></code></pre><p>至此我们就完成了图片的压缩，这里上完整的compress函数的代码：</p><pre><code class="highlight reasonml"><span class="keyword">function</span> compress(base64Image, callback) &#123;            <span class="keyword">let</span> maxW = <span class="number">1024</span>            <span class="keyword">let</span> maxH = <span class="number">1024</span>            const image = <span class="keyword">new</span> <span class="constructor">Image()</span>            image.src = base64Image            image.add<span class="constructor">EventListener('<span class="params">load</span>', <span class="params">function</span> (<span class="params">e</span>)</span> &#123;                <span class="keyword">let</span> radio  <span class="comment">// 图片压缩比</span>                <span class="keyword">let</span> needCompress = <span class="literal">false</span>   <span class="comment">//是否需要压缩</span>                <span class="keyword">if</span> (maxW &lt; image.naturalWidth) &#123;                    needCompress = <span class="literal">true</span>                    radio = image.naturalWidth<span class="operator"> / </span>maxW                    maxH = image.naturalHeight<span class="operator"> / </span>radio                &#125;                <span class="keyword">if</span> (maxH &lt; image.naturalHeight) &#123;                    needCompress = <span class="literal">true</span>                    radio = image.naturalHeight<span class="operator"> / </span>maxH                    maxW = image.naturalWidth<span class="operator"> / </span>radio                &#125;                <span class="keyword">if</span> (!needCompress) &#123;                    maxW = image.naturalWidth                    maxH = image.naturalHeight                &#125;                const canvas = document.create<span class="constructor">Element('<span class="params">canvas</span>')</span>                canvas.set<span class="constructor">Attribute('<span class="params">id</span>', '<span class="params">__compress__</span>)</span>')                canvas.width = maxW                canvas.height = maxH                canvas.style.visibility = 'hidden'                document.body.append<span class="constructor">Child(<span class="params">canvas</span>)</span>                const ctx = canvas.get<span class="constructor">Context('2d')</span>                ctx.clear<span class="constructor">Rect(0, 0, <span class="params">maxW</span>, <span class="params">maxH</span>)</span>                ctx.draw<span class="constructor">Image(<span class="params">image</span>, 0, 0, <span class="params">maxW</span>, <span class="params">maxH</span>)</span>                const compressImage = canvas.<span class="keyword">to</span><span class="constructor">DataURL('<span class="params">image</span><span class="operator">/</span><span class="params">jpg</span>', 0.9)</span>                canvas.remove<span class="literal">()</span>                callback<span class="operator"> &amp;&amp; </span>callback(compressImage)                <span class="comment">//操作完之后移出image对象</span>                image.remove<span class="literal">()</span>            &#125;)            document.body.append<span class="constructor">Child(<span class="params">image</span>)</span>        &#125;</code></pre><p>这个函数为什么需要callback呢？因为操作压缩完的图片就可以上传服务器了，这里就可以调用上传到服务器的函数，由于需要给compress传值，所以我们需要对convertImageToBase64的调用做出一点改造</p><pre><code class="highlight reasonml">convert<span class="constructor">ImageToBase64(<span class="params">file</span>, (<span class="params">base64Image</span>)</span> =&gt; compress(base64Image, uploadToServer))<span class="keyword">function</span> upload<span class="constructor">ToServer(<span class="params">compressImage</span>)</span> &#123;    console.log('upload <span class="keyword">to</span> server');&#125;</code></pre><p>由于偷懒，所以这个上传方法就这样给个示例就好了。至此压缩就此结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;style&gt;
article p{
    font-size:16px;
    line-height:28px;
}
&lt;/style&gt;

&lt;p&gt;&amp;emsp; &amp;emsp; 最近发现了一个可以利用canvas压缩图片的方法，于是乎我就自己尝试了一下，发现效果还是不错的，可以控制压缩的输出格式，还有压缩比例。为什么会发现这个东西呢，因为我最近研究东西的时候突然想到一个需求，那就是我们前端能不能在上传图片之前压缩一下图片，于是乎就有一系列的操作了。原理呢就是利用了canvas的api以及浏览器提供的FileReader和Image的两个对象。老规矩，先把歌安排上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>建议改成：this的全面解析(二)</title>
    <link href="http://yoursite.com/2020/03/13/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2020/03/13/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%BA%8C)/</id>
    <published>2020-03-13T12:28:49.000Z</published>
    <updated>2020-03-13T12:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>article p{    font-size:16px;    line-height:28px;}</style><p>大家好！许久不见甚是想念，仅仅过了两天不到，我又开始给你们写技(cai)术(ji)文章了。<br>上回说到，这this的指向，以及作用域的问题，其实我后来发现这个两个说的好像都差不多，但是呢，过于懒得我就不想改了。<br>所以今天，我就立马给大家介绍this的绑定规则！！！是不是好高兴，好激动，甚至有点想打赏我了。好的，我自恋了，下面直接开始。</p><a id="more"></a><p><img src="./jienigui.jpg" alt="杰尼龟-冲冲冲"></p><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>虽然我上篇文章粗略的说过，理解this的绑定，需要知道函数的调用位置，才能确认this绑定的对象。<br>下面是《你不知道的JavaScript上》中的一个例子：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//当前调用栈是：baz</span>    <span class="comment">//因此，当前调用位置是全局作用域</span>    <span class="built_in">console</span>.log(<span class="string">'baz'</span>);    bar(); <span class="comment">//&lt;-- bar的调用位置</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//当前调用栈是：baz -&gt; bar</span>    <span class="comment">//因此，当前调用位置是在baz中</span>    <span class="built_in">console</span>.log(<span class="string">'bar'</span>);    foo(); <span class="comment">//&lt;-- foo的调用位置</span>&#125;<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//当前调用栈是：baz -&gt; bar -&gt; foo</span>    <span class="comment">//因此，当前调用位置是在bar中</span>    <span class="built_in">console</span>.log(<span class="string">'foo'</span>);&#125;baz()； <span class="comment">// &lt;-- baz的调用位置</span></code></pre><p>学习JS的同学，多少听过栈跟堆，当然这不是本文的重点，但是为了照顾同学，我决定以后出一篇（有机会的话，嘿嘿）。</p><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p>接下来我们就会看看在函数的执行过程中调用位置如何决定this的绑定对象。<br>主要分为了四个规则，下面会逐一分析。</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则。</p><p>先来个简单的例子：</p><pre><code class="highlight javascript"><span class="keyword">var</span> a = <span class="number">2</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;foo() <span class="comment">// 2</span></code></pre><p>明显这个例子，就是算是初学者也会说的出答案。这其实就是默认绑定的一个最简单的例子，那么我们是怎么知道这里运用了默认绑定呢？可以通过分析调用位置来看看foo()是如何调用的。在代码中，foo()是直接使用不带任何修饰的函数引用进行的调用，因此只能使用默认绑定，无法使用其他规则。<br>但是如果是严格模式下(strict mode)的话,则不会绑定到全局对象中，因此this会绑定到undefined</p><pre><code class="highlight javascript"><span class="meta">'use strict'</span><span class="keyword">var</span> a = <span class="number">2</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;foo() <span class="comment">// TypeError: this is undefined</span></code></pre><p>但是在《你不知道的js的上》中提到了一个很微妙的例子，就是假如调用位置在严格模式(strict mode)下的话，则不会影响到默认绑定。</p><pre><code class="highlight javascript"><span class="keyword">var</span> a = <span class="number">2</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="meta">    'use strict'</span>     foo() <span class="comment">// 2</span>&#125;)()</code></pre><h3 id="秒杀默认绑定的技巧"><a href="#秒杀默认绑定的技巧" class="headerlink" title="秒杀默认绑定的技巧"></a>秒杀默认绑定的技巧</h3><p>对于初学者来说，就会问到：’有没有可以立马判断到这是默认绑定的技巧啊，我怕我脑子记太多不够用啊。’<br>既然你诚心诚意的问，我就大发慈悲的告诉你：’有！马上给你安排上’<br>在下面的三种场景下，this会100%指向window：</p><ul><li>立即执行函数（IIFE）</li><li>setTimeout 中传入的函数</li><li>setInterval 中传入的函数</li></ul><p>只要看到判断this的题，没必要第一步就去老实分析这个this绑定到那么对象上，而是应该先定位<strong>this 是否出现在了以上三种类型的函数里面</strong>。如果是，那么想也不想，直接去对应 window 就好了～</p><p>做题快感无非是秒杀嘛，不然为什么那么多人喜欢看<a href="https://baike.baidu.com/item/%E4%B8%80%E6%8B%B3%E8%B6%85%E4%BA%BA/1966105?fr=aladdin" target="_blank" rel="noopener">一拳超人</a></p><h4 id="立即执行函数（IIFE）、"><a href="#立即执行函数（IIFE）、" class="headerlink" title="立即执行函数（IIFE）、"></a>立即执行函数（IIFE）、</h4><p>所谓立即执行函数，就是定义后立刻调用的匿名函数（参见下面这道例题里 hello 方法的函数体里这种写法）。</p><pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">'RadiomM'</span><span class="keyword">var</span> me = &#123;  name: <span class="string">'ydw'</span>,  <span class="comment">// 声明位置</span>  sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">`你好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)  &#125;,  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    (<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;      <span class="comment">// 调用位置</span>      cb()    &#125;)(<span class="keyword">this</span>.sayHello)  &#125;&#125;me.hello() <span class="comment">// 大家再猜下输出啥了？</span></code></pre><p>看到这里，我想你必须马上立刻给我喊出答案，那就是RaidomM。如果你不是立马想出答案的，我建议你再好好反省一下！！！！<br>好吧，你该反省完了，那么我接着说。</p><p>其实，即便不考虑立即执行的匿名函数这种所谓的“特殊情况”，大家按照我们上面的指向原则来分析，结果也是一样一样的。 立即执行函数作为一个匿名函数，在被调用的时候，我们往往就是直接调用，而不会（也无法）通过属性访问器（ 即 xx.xxx） 这样的形式来给它指定一个所在对象，所以它的 this 是非常确定的，就是默认的全局对象 window。</p><h4 id="setTimeout-和-setInterval-中传入的函数"><a href="#setTimeout-和-setInterval-中传入的函数" class="headerlink" title="setTimeout 和 setInterval 中传入的函数"></a>setTimeout 和 setInterval 中传入的函数</h4><p>众所周知，其实setTimeout和setInterval中的函数机制其实没什么区别，他们就是兄弟，既然是兄弟，那我就只拿一个兄弟setTimeout开刀了：</p><pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">'RadiomM'</span><span class="keyword">var</span> me = &#123;  name: <span class="string">'ydw'</span>,  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log(<span class="string">`你好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)    &#125;)  &#125;&#125;me.hello() <span class="comment">// 你好，我是RadiomM</span></code></pre><p>是不是觉得好神奇？我们的 this.name 明明看起来是在 me.hello () 里被调用的，结果却输出了 window.name。 setTimeout 到底对函数做了什么？</p><p>其实，我们所看到的延时效果（setTimeout）和定时效果（setInterval），都是在全局作用域下实现的。无论是 setTimeout 还是 setInterval 里传入的函数，都会首先被交付到全局对象手上。因此，函数中 this 的值，会被自动指向 window。</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>所谓的隐式绑定其实就是函数调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。<br>是的，概念就是这么拗口，直接上代码：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)&#125;<span class="keyword">var</span> obj =&#123;  a: <span class="number">2</span>,  foo: foo&#125;obj.foo()  <span class="comment">// 2</span></code></pre><p>是不是很眼熟？没错，上一篇文章可是已经做过例子了！！</p><p>首先需要注意的是foo函数的声明方式，及其之后是如何被当做引用属性添加到obj中的。<br>但是无论是直接在obj中定义还是先定义在添加为引用属性，这个函数严格来说都不属于obj对象。</p><p>然而，调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象”拥有”或者”包含“函数引用。<br>没错，这就是隐式绑定规则，将函数的this绑定到了上下文对象中（如上面obj对象），所以this.a和obj.a是一样的</p><p>但是有一点是值得注意的，那就是对象属性引用链中只有最接近的一层有效。看下面的例子：<br> <pre><code class="highlight delphi"> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span><span class="function"><span class="comment">    console.log(this.a)</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">var</span> <span class="title">obj1</span> =<span class="comment">&#123;</span></span><span class="function"><span class="comment">  a: 12,</span></span><span class="function"><span class="comment">  foo: foo</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">var</span> <span class="title">obj12</span> =<span class="comment">&#123;</span></span><span class="function"><span class="comment">  a: 22,</span></span><span class="function"><span class="comment">  foo: foo</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"><span class="title">obj1</span>.<span class="title">obj2</span>.<span class="title">foo</span><span class="params">()</span>  <span class="comment">// 22</span></span><span class="function"><span class="title">obj2</span>.<span class="title">obj1</span>.<span class="title">foo</span><span class="params">()</span>  <span class="comment">// 12</span></span></code></pre><br> <img src="./qiguaidezhishi.jpeg" alt="奇怪的知识增加了！"></p><p> <strong>注意了，要是面试问到了，你记得一定要说是我告诉你的！！是的，这会大大的加分！！！</strong><br> <strong>什么？你不信，那你可以收藏一下，关闭网页了。</strong></p><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p> 一个非常常见的问题，或者你平时刷题也会看见的。表现大多是<strong>被隐式绑定的函数会丢失绑定对象，也就是说<br> 它会应用默认绑定，从而把this绑定到全局对象或者undefined上，这个取决于是否是严格模式（strict mode）</strong></p><p> 准备好了吗？接招<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);&#125;<span class="keyword">var</span> obj = &#123;   a: <span class="number">2</span>,   foo: foo&#125;<span class="keyword">var</span> bar = obj.foo  <span class="comment">// 函数别名</span><span class="keyword">var</span> a = <span class="string">"Oh My God"</span>bar(); <span class="comment">// ?</span></code></pre><br> 来吧，多读几遍定义，来说说你的答案是什么？</p><p> 没错，答案就是”Oh My God”，你猜到了吗？什么！？你没猜到，那正好，不然我没法写下去了。</p><p> 看清楚了！虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。什么意思？就是bar()和foo()其实是一样的。<br> 看到foo()，按照我们上面说的，明显就是一个默认规则了。</p><p> 来点开发的时候经常用到的，就是传入回调函数时：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);&#125;<span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;  <span class="comment">// fn其实引用的是foo</span>  fn() <span class="comment">//  &lt;-- 调用位置</span>&#125;<span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>,  foo: foo&#125;<span class="keyword">var</span> a = <span class="string">"Oh My God"</span>doFoo( obj.foo ) <span class="comment">// "Oh My God"</span></code></pre></p><p> 参数传递是<strong>按值传递的，而且算是一种隐式赋值</strong>，因此，从结果上看跟上面的例子没有两样。</p><p> 这时候你就可能会问：“哎呀，这是我自己定义的函数，如果不是自己定义的函数会怎么样啊？”<br> 答案是一样的，没有什么区别的，把setTimeout兄弟抬上来：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);&#125; <span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>,  foo: foo&#125;<span class="keyword">var</span> a = <span class="string">"Oh My God"</span>setTimeout( obj.foo, <span class="number">100</span>) <span class="comment">// "Oh My God"</span></code></pre></p><p> <strong>JavaScript环境中内置的setTimeout()函数实现和下面的伪代码类似：</strong><br> <pre><code class="highlight reasonml"><span class="keyword">function</span> set<span class="constructor">Timeout(<span class="params">fn</span>,<span class="params">delay</span>)</span> &#123;  <span class="comment">// 等待delay毫秒</span>  fn<span class="literal">()</span>&#125;</code></pre></p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p> 显式绑定无非就是用call、apply、bind函数，将this绑定到指定的上下文对象。这三个函数的第一个参数是一个对象，没错<br> 就是给this准备的，接着在调用函数将其绑定到this。<br> 先来个小栗子：</p> <pre><code class="highlight delphi"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span><span class="function"><span class="comment">  console.log(this.a)</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">var</span> <span class="title">obj</span> =<span class="comment">&#123;</span></span><span class="function"><span class="comment">  a: 2</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">foo</span>.<span class="title">call</span><span class="params">( obj )</span>    <span class="comment">//2</span></span><span class="function"></span><span class="function"><span class="title">foo</span>.<span class="title">apply</span><span class="params">( obj )</span>  <span class="comment">//2</span></span><span class="function"></span><span class="function"><span class="title">var</span> <span class="title">bar</span> = <span class="title">foo</span>.<span class="title">bind</span><span class="params">(obj)</span></span><span class="function"></span><span class="function"><span class="title">bar</span><span class="params">()</span>            <span class="comment">//2</span></span></code></pre><p>看到区别了吗？call和apply直接使用即可，而bind需要变量接受返回值，然后再调用。然后我就可分类讲了。</p><h4 id="改变后直接调用函数"><a href="#改变后直接调用函数" class="headerlink" title="改变后直接调用函数"></a>改变后直接调用函数</h4><p> call和apply都是可以直接调用实现的，那么它们有什么区别吗？</p><p> 看下面小栗子：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>)</span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" go "</span>+ a +<span class="string">" and "</span>+ b)&#125;<span class="keyword">var</span> obj = &#123;  name:<span class="string">'RaidomM'</span>&#125;foo.call(obj,<span class="string">'成都'</span>,<span class="string">'广东'</span>)     <span class="comment">// RaidomM go 成都 and 广东</span>foo.apply(obj,[<span class="string">'成都'</span>,<span class="string">'广东'</span>])  <span class="comment">// RaidomM go 成都 and 广东</span></code></pre></p><p> 可以注意到，call与apply只是传参的方式不一样，但是函数内部获取参数的方法确实一样的！<br> 在这里先留问题，如何实现一个call或者apply呢？可以解决上面提及到了<strong>隐式丢失</strong>的问题吗？</p><h4 id="改变后返回一个函数"><a href="#改变后返回一个函数" class="headerlink" title="改变后返回一个函数"></a>改变后返回一个函数</h4><p> 再看下面的一个小栗子：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b</span>)</span>&#123;  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a ,b)  <span class="keyword">return</span> <span class="keyword">this</span>.a + b&#125;<span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>&#125;<span class="keyword">var</span> bar = foo.bind(obj)<span class="keyword">var</span> c = bar(<span class="number">3</span>) <span class="comment">// 2,3</span><span class="built_in">console</span>.log( c ) <span class="comment">// 5</span></code></pre><br> 可以看到，bind会返回一个函数。这个函数可以暂时理解为foo（实际上并不是一模一样的），然后你再调用函数传参等。</p><p> <strong>一个可以值得提到的点</strong>，那就是bind的绑定永远起作用的是第一个<br> <pre><code class="highlight javascript"><span class="keyword">let</span> a = &#123;&#125;<span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;fn.bind().bind(a)() <span class="comment">// =&gt; ?</span></code></pre><br> 如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式<br> <pre><code class="highlight javascript"> <span class="comment">// fn.bind().bind(a) 等于</span><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> fn.apply()  &#125;.apply(a)&#125;fn2()</code></pre><br> 可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。<br> <pre><code class="highlight javascript"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">'ydw'</span> &#125;<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;foo.bind(a)() <span class="comment">// =&gt; 'ydw'</span></code></pre></p><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p> 如果简单说的话，可以直接看一下代码：<br> <pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;  <span class="keyword">this</span>.a = a&#125;<span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)<span class="built_in">console</span>.log(bar.a) <span class="comment">// 2</span></code></pre></p><p>当然，这其实没有那么简单，其中涉及到<strong>构造函数</strong>，<strong>new实现了什么的操作</strong>，<strong>原型和原型链</strong>等等。<br>但是你现在只需要知道，使用new操作的，那么this就永远绑定到创建的实例对象上面（上面的代码就是bar）</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数是ES6新提出的一个<strong>带返回值函数的简写方式</strong>，它的this就跟词法作用域一样，一旦绑定了，那么它的this，<br>就永远绑定在那里了。上代码：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;<span class="keyword">var</span> obj1 = &#123;  a: <span class="number">2</span>&#125;<span class="keyword">var</span> obj2 = &#123;  a: <span class="number">3</span>&#125;<span class="keyword">var</span> bar = foo.call(obj1)bar.call(obj2); <span class="comment">// 2 不是3</span></code></pre><p>foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar（引用箭头函数）的this也会绑定<br>到obj1，箭头函数的绑定无法被修改，就是new也是不行的。</p><p>箭头函数常常用回调函数中。看下面代码：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;    <span class="comment">// 这里的this在词法上继承自foo()</span>    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)  &#125;)&#125;<span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>&#125;foo.call(obj) <span class="comment">// 2</span></code></pre><p>然而在ES6之前，我们解决这个问题的办法是下面的：</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">var</span> that = <span class="keyword">this</span>  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)  &#125;, <span class="number">100</span>)&#125;<span class="keyword">var</span> obj = &#123;  a: <span class="number">2</span>&#125;foo.call(obj) <span class="comment">// 2</span></code></pre><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>关于优先级，我想直接引用yck的《前端面试之道》中的一张图来给大家看</p><p><img src="./this.jpg" alt="判断this优先级"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于是写完了，其实后面的内容会相对的写的比较少，为什么呢？那肯定是为了之后可以再写文章啦（没错，就是水文章）</p><p>开玩笑的，事实上写起来会复杂的多，而这篇文章的篇幅已经是比较多了，再多的话，你们就没心思读下去了。</p><p>下面开始技术总结（<strong>其实看了优先级的那种图就可以了</strong>）：</p><p>1、函数是否在new中调用（new绑定），是则this绑定到实例对象上</p><p>2、函数是否通过call，apply，bind显示绑定的，如果是，this绑定的是指定的对象</p><p>3、函数是否调用在上下文对象（隐式绑定），是则this绑定到那个上下文对象中</p><p>4、如果都不是那么就是使用默认规则，严格模式下绑定到undefined，否则绑定到全局对象中（ 浏览器window, Node环境gobal）</p><p>好了，看到这里大家也不容易，所以给大家再上一首歌吧！</p>    <div id="aplayer-fSXrOKXa" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="722928" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>如果文章有错误的地方，希望小哥哥小姐姐们在评论区指出，毕竟作者的水平确实有限。</p>]]></content>
    
    <summary type="html">
    
      &lt;style&gt;
article p{
    font-size:16px;
    line-height:28px;
}
&lt;/style&gt;

&lt;p&gt;大家好！许久不见甚是想念，仅仅过了两天不到，我又开始给你们写技(cai)术(ji)文章了。&lt;br&gt;上回说到，这this的指向，以及作用域的问题，其实我后来发现这个两个说的好像都差不多，但是呢，过于懒得我就不想改了。&lt;br&gt;所以今天，我就立马给大家介绍this的绑定规则！！！是不是好高兴，好激动，甚至有点想打赏我了。好的，我自恋了，下面直接开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>建议改成：this的全面解析(一)</title>
    <link href="http://yoursite.com/2020/03/12/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%B8%80)/"/>
    <id>http://yoursite.com/2020/03/12/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%B8%80)/</id>
    <published>2020-03-12T05:27:24.000Z</published>
    <updated>2020-03-12T05:27:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>article p{    font-size:16px;    line-height:28px;}</style><p>嗨，大家好！过了那么几天我又开始写文章了，这次给大家带来的是this的全面解析。会不会有人会问，怎么突然就这么高产了？其实是这样的，因为这次疫情的出现，让我原本的计划出现了变动，当然也让我认清了我小公司的老板是多么的抠门。所以接下来的文章，基本都是会写一些面试多次会考的问题。当然，作为前端工程师，那么我们的基本功除了HTML，CSS意外，最重要的就是这个JS中的this。废话说完，那么接下来我们就开始了。</p><a id="more"></a><h2 id="this是指向的是谁？"><a href="#this是指向的是谁？" class="headerlink" title="this是指向的是谁？"></a>this是指向的是谁？</h2><p>在多数的情况下，this指向的是调用方法的那个对象。<strong>简单的说就是谁调用函数，那么this就是指向这个对象。</strong><br> <pre><code class="highlight delphi"><span class="keyword">var</span> a = <span class="number">1</span><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span><span class="function"><span class="comment">    console.log(this.a)</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"><span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出 1</span></span><span class="function"></span><span class="function"><span class="title">let</span> <span class="title">obj</span> = <span class="comment">&#123;</span></span><span class="function"><span class="comment">    a: 2,</span></span><span class="function"><span class="comment">    foo:foo</span></span><span class="function"><span class="comment">&#125;</span></span><span class="function"></span><span class="function"><span class="title">obj</span>.<span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出2</span></span></code></pre></p><p>上面的代码对于老手来说应该没有什么问题。这里我对新手提点注意的点，那就是foo()的调用其实相当于window.foo()，又因为var定义的变量在<strong>非严格模式下</strong>会自动挂载到全局对象中，<strong>在浏览器中，指向 window；在 Node 中，指向 Global。（严格模式下，指向 undefined）</strong></p><h2 id="this的作用域指向哪里？"><a href="#this的作用域指向哪里？" class="headerlink" title="this的作用域指向哪里？"></a>this的作用域指向哪里？</h2><p>很多新手学习JavaScript的同学来说，都会认为this指向的是函数的作用域，实际上并不是这样的，实际上你看了上面的两个例子之后，<br>你就会发现，第一个符合，而第二个却是不符合的。再看下面一个经典的题目，你可能就有点意思了。（不懂作用域的同学，之后我也会出一篇的。）</p><pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">"zhangsan"</span>;<span class="keyword">var</span> obj = &#123;    name:<span class="string">"RadiomM"</span>,    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         <span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) &#125;;        x();    &#125;&#125;obj.fn() <span class="comment">// zhangsan</span></code></pre><p>是不是答案有点出乎了意料，这大多是因为觉得this指向函数作用域的关系，看x函数在obj对象的属性方法中定义，想当然的以为这时候调用函数x的就是这个obj对象，事实上这是大错特错的，有必要简单的说说，什么是声明，什么是调用。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>看下面的例子：</p><pre><code class="highlight cs"><span class="keyword">var</span> a = <span class="number">1</span><span class="function">funciton <span class="title">foo</span>(<span class="params"></span>)</span> &#123;    console.log(a)&#125;</code></pre><p>没错，就是这么简单，这就是声明函数foo。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>看下面的例子：</p><pre><code class="highlight stylus"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span>funciton foo() &#123;    console.log(a)&#125;<span class="comment">// 这就是调用</span><span class="function"><span class="title">foo</span><span class="params">()</span></span></code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>重要的事情说三遍，建议你大声跟着读下面的字：<br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br>实际上，你读完上面的字，你还是会疑惑，那么为什么输出的就是这个zhangsan呢？其实，我在第一个例子中<br>已经给了提示了，实际上这个x()就相当于window.x()，那么这道题就相当的明了了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>话不多说，直接抬总结上来：</p><p>1、this绑定实际上是在函数被调用时发生的绑定，它的指向取决于函数在哪里被调用。</p><p>2、this的作用域并不是指向函数的作用域。</p><p>其实这篇文章仅仅是入门this的基础，下一篇文章我将会全面解析this的绑定规则。<br>看到这里你可能会问什么会是下一篇呢？因为我写累了啊，哈哈。<br>给大兄弟来首歌轻松轻松。（这篇文章就是在快乐气氛下写完的。学习可别忘了快乐，hasaki！）</p>    <div id="aplayer-qeYUXXwW" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="29732992" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>如果文章有错误的地方，希望小哥哥小姐姐们在评论区指出，毕竟作者的水平确实有限。</p>]]></content>
    
    <summary type="html">
    
      &lt;style&gt;
article p{
    font-size:16px;
    line-height:28px;
}
&lt;/style&gt;


&lt;p&gt;嗨，大家好！过了那么几天我又开始写文章了，这次给大家带来的是this的全面解析。会不会有人会问，怎么突然就这么高产了？其实是这样的，因为这次疫情的出现，让我原本的计划出现了变动，当然也让我认清了我小公司的老板是多么的抠门。所以接下来的文章，基本都是会写一些面试多次会考的问题。当然，作为前端工程师，那么我们的基本功除了HTML，CSS意外，最重要的就是这个JS中的this。废话说完，那么接下来我们就开始了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>手动实现一个v-model的不同做法(含封装组件用法)</title>
    <link href="http://yoursite.com/2020/03/08/model/"/>
    <id>http://yoursite.com/2020/03/08/model/</id>
    <published>2020-03-08T02:02:42.000Z</published>
    <updated>2020-03-08T02:02:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>由于疫情的原因啊，我猜大多数人都跟我一样，在家里度过，偶尔学习学习。这不，我遇到了<strong>一个如何手动一个v-model</strong>的问题，由此展开了学习。<br>在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：</p><a id="more"></a><pre><code class="highlight routeros">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">v-model</span>=<span class="string">"name"</span>&gt;</code></pre><p>实则是等于下面的：</p><pre><code class="highlight routeros">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> :<span class="attribute">value</span>=<span class="string">"name"</span> @<span class="attribute">input</span>=<span class="string">"name=<span class="variable">$event</span>.target.value"</span>&gt;</code></pre><p>也就是说，v-model就是<strong>绑定了一个名为value的props和一个事件input</strong><br>            注意：所以在子组件中可以通过props中定义value接受值，然后通过$emit触发input事件传新值并修改。 </p><p>知道了这个知识之后啊，那么我们就开始实现一个自定义的v-model啦<del>~</del></p><h2 id="一、最简单的实现方法"><a href="#一、最简单的实现方法" class="headerlink" title="一、最简单的实现方法"></a>一、最简单的实现方法</h2><p>首先是父组件的代码：</p><pre><code class="highlight xquery"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xquery">&#123;<span class="built_in">&#123;name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><span class="xml">      <span class="comment">&lt;!-- 等同于下面 --&gt;</span></span><span class="xml">      <span class="comment">&lt;!-- </span></span><span class="xml"><span class="comment">&lt;son type="text" :value="name" @input="name=子组件传回来的值"&gt; --&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><span class="xml">import Son from './son'</span><span class="xml">export default </span><span class="xquery">&#123;</span><span class="xquery"> <span class="built_in"> name</span>: <span class="string">""</span>,</span><span class="xquery">  data() &#123;</span><span class="xquery">    <span class="keyword">return</span> &#123;</span><span class="xquery">       <span class="built_in"> name</span>:<span class="string">'ydw'</span>,</span><span class="xquery">    &#125;</span><span class="xml">  &#125;,</span><span class="xml">  components: </span><span class="xquery">&#123;</span><span class="xquery">      Son</span><span class="xquery">  &#125;</span><span class="xml">&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></code></pre><p>然后是子组件的代码：</p><pre><code class="highlight pgsql">&lt;<span class="keyword">template</span>&gt;  &lt;div <span class="keyword">class</span>&gt;      &lt;<span class="keyword">input</span> <span class="keyword">type</span>="text" :<span class="keyword">value</span>="value" @input="$emit('input',$event.target.value)"&gt;  &lt;/div&gt;&lt;/<span class="keyword">template</span>&gt;&lt;script <span class="keyword">type</span>="text/javascript"&gt;export <span class="keyword">default</span> &#123;  <span class="type">name</span>: "",  props:&#123;      <span class="keyword">value</span>:&#123;          <span class="keyword">type</span>: String,          defalut ()               <span class="keyword">return</span> <span class="string">''</span>          &#125;      &#125;  &#125;,  data() &#123;    <span class="keyword">return</span> &#123;    &#125;  &#125;,  components: &#123;  &#125;&#125;&lt;/script&gt;</code></pre><p>父组件中我加了一个注释的代码行，其实是帮助我自己理解的，不知道有没有小伙伴跟我一样，第一次看的时候压根不知道它在做什么的？哭唧唧。</p><h2 id="二、使用watch和-emit实现"><a href="#二、使用watch和-emit实现" class="headerlink" title="二、使用watch和$emit实现"></a>二、使用watch和$emit实现</h2><p>跟上面的一个有些类似，只不过上面是用本身input事件的作用，通过input事件的频发触发传递值给父组件，这里只是将这个过程换成了通过watch监听值得变化，然后通过input事件触发函数事件，函数事件里提交变化的值给父组件。好了，我只需要修改子组件，如下：</p><pre><code class="highlight kotlin">&lt;template&gt;  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type=<span class="string">"text/javascript"</span>&gt;export <span class="keyword">default</span> &#123;  name: <span class="string">""</span>,  props: &#123;    value: &#123;      type: String,      defalut() &#123;        <span class="keyword">return</span> <span class="string">""</span>;      &#125;    &#125;  &#125;,  <span class="keyword">data</span>() &#123;    <span class="keyword">return</span> &#123;      sonVal:<span class="keyword">this</span>.value    &#125;;  &#125;,  watch: &#123;    value(newval) &#123;      <span class="keyword">this</span>.sonVal = newval    &#125;  &#125;,  methods:&#123;    handleModel(e)&#123;        <span class="keyword">this</span>.sonVal = e.target.value        <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,<span class="keyword">this</span>.sonVal)    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><p>通过watch监听props值得变化，赋值给子组件本身定义的sonVal，绑定在input里。然后利用input事件触发函数，提交到父组件。</p><h2 id="三、使用最新的语法，model属性。"><a href="#三、使用最新的语法，model属性。" class="headerlink" title="三、使用最新的语法，model属性。"></a>三、使用最新的语法，model属性。</h2><p>本来我是不知道有这个属性的，就是在网上搜索关于v-model实现方法的时候，就不知不觉的查到这个属性，查看官方文档如下：<br><img src="./model.png" alt="avatar"></p><p>也就是说这个属性是为了回避props定义的value这个名字的。</p><p>下面看看它的用法，我们先看子组件怎么修改：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>&gt;</span>    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"val"</span> @<span class="attr">input</span>=<span class="string">"$emit('change',$event.target.value)"</span> /&gt;</span>  <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><span class="actionscript">  name: <span class="string">""</span>,</span>  model:&#123;<span class="actionscript">    prop:<span class="string">'val'</span>,</span><span class="actionscript">    event:<span class="string">'change'</span></span>  &#125;,  props: &#123;    val: &#123;<span class="javascript">      type: <span class="built_in">String</span>,</span>      defalut() &#123;<span class="actionscript">        <span class="keyword">return</span> <span class="string">""</span>;</span>      &#125;    &#125;  &#125;,  data() &#123;<span class="actionscript">    <span class="keyword">return</span> &#123;</span>    &#125;;  &#125;&#125;;<span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>model属性中prop是重新命名传值的名字，而event则是重新命名事件的名字，但是同样的，props中的传值名字必须与model属性中的prop的名字一样。其实只要对比一下第一种方法就知道，vue多出一个model属性是为了value这个名字可以使用。</p><h3 id="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"><a href="#同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件" class="headerlink" title="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"></a>同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件</h3><pre><code class="highlight kotlin">&lt;template&gt;  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type=<span class="string">"text/javascript"</span>&gt;export <span class="keyword">default</span> &#123;  name: <span class="string">""</span>,  model:&#123;    prop:<span class="string">'val'</span>,    event:<span class="string">'change'</span>  &#125;,  props: &#123;    <span class="keyword">val</span>: &#123;      type: String,      defalut() &#123;        <span class="keyword">return</span> <span class="string">""</span>;      &#125;    &#125;  &#125;,  <span class="keyword">data</span>() &#123;    <span class="keyword">return</span> &#123;      sonVal:<span class="keyword">this</span>.<span class="keyword">val</span>    &#125;;  &#125;,  watch: &#123;    value(newval) &#123;      <span class="keyword">this</span>.sonVal = newval    &#125;  &#125;,  methods:&#123;    handleModel(e)&#123;        <span class="keyword">this</span>.sonVal = e.target.value        <span class="keyword">this</span>.$emit(<span class="string">'change'</span>,<span class="keyword">this</span>.sonVal)    &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>距离文章发布已经有半年多的时间了，最近用vue2.0封装elementUI，在封装form表单的时候恰巧用上了这个吃灰许久的东西记录一下。</p><p>首先讲我简单的封装代码上来：</p><pre><code class="highlight vim"><span class="symbol">&lt;template&gt;</span>  &lt;div class=<span class="string">"form-container"</span>&gt;    &lt;<span class="keyword">el</span>-form      :model=<span class="string">"filterObject"</span>      label-position=<span class="string">"left"</span>      :label-width=<span class="string">"labelWidth"</span>    &gt;      &lt;<span class="keyword">el</span>-row :gutter=<span class="string">"10"</span>&gt;        &lt;<span class="keyword">el</span>-<span class="keyword">col</span>          v-<span class="keyword">for</span>=<span class="string">"item in formData"</span>          :key=<span class="string">"item.prop"</span>          :span=<span class="string">"item.span || 8"</span>        &gt;          &lt;<span class="keyword">el</span>-form-item :label=<span class="string">"item.label"</span>&gt;            &lt;<span class="keyword">el</span>-<span class="built_in">input</span>              v-<span class="keyword">if</span>=<span class="string">"item.type === 'text'"</span>              v-model=<span class="string">"filterObject[item.prop]"</span>              clearable              :disabled=<span class="string">"item.disabled || false"</span>              :placeholder=<span class="string">"item.placeholder"</span>            &gt;&lt;/<span class="keyword">el</span>-<span class="built_in">input</span>&gt;            &lt;<span class="keyword">el</span>-select              v-<span class="keyword">if</span>=<span class="string">"item.type === 'select'"</span>              v-model=<span class="string">"filterObject[item.prop]"</span>              clearable              :placeholder=<span class="string">"item.placeholder"</span>              @change=<span class="string">"handleChange"</span>            &gt;              &lt;<span class="keyword">el</span>-option                v-<span class="keyword">for</span>=<span class="string">"sub in item.arr"</span>                :key=<span class="string">"sub.value"</span>                :label=<span class="string">"sub.label"</span>                :value=<span class="string">"sub.value"</span>              &gt;&lt;/<span class="keyword">el</span>-option&gt;            &lt;/<span class="keyword">el</span>-select&gt;          &lt;/<span class="keyword">el</span>-form-item&gt;        &lt;/<span class="keyword">el</span>-<span class="keyword">col</span>&gt;      &lt;/<span class="keyword">el</span>-row&gt;    &lt;/<span class="keyword">el</span>-form&gt;  &lt;/div&gt;&lt;/template&gt;<span class="symbol">&lt;script&gt;</span>export default &#123;  <span class="keyword">mode</span><span class="variable">l:</span> &#123;    prop: <span class="string">'filterObject'</span>,    even<span class="variable">t:</span> <span class="string">'change'</span>,  &#125;,  prop<span class="variable">s:</span> &#123;    filterObjec<span class="variable">t:</span> &#123;      <span class="built_in">type</span>: Object,      default() &#123;        <span class="keyword">return</span> &#123;&#125;      &#125;,    &#125;,    labelWidth: &#123;      <span class="built_in">type</span>: String,      defaul<span class="variable">t:</span> <span class="string">'80px'</span>,    &#125;,    formDat<span class="variable">a:</span> &#123;      <span class="built_in">type</span>: Array,      default() &#123;        <span class="keyword">return</span> []      &#125;,    &#125;,  &#125;,  data() &#123;    <span class="keyword">return</span> &#123;&#125;  &#125;,  method<span class="variable">s:</span> &#123;    handleChange() &#123;      console.<span class="built_in">log</span>(this.filterObject)    &#125;,  &#125;,&#125;&lt;/script&gt;</code></pre><p>其中的filterObject就是今天的主角了，我的想法是在父组件直接传递一个对象进来，在进行相关操作的时候，父组件直接可以在外面用到这些值，而不是通过子组件暴露方法获取这些值。(ps:在封装search组件的时候可以这么做，向外暴露search，reset方法可以暴露子组件里面的值。其实封装search跟这个form有点相似，都是用elementUI的form表单来封装的。)</p><p>接下来是父组件的代码：</p><pre><code class="highlight vim"><span class="symbol">&lt;template&gt;</span>  &lt;div class=<span class="string">"home"</span>&gt;    &lt;HHform      :formData=<span class="string">"searchOptions"</span>      labelWidth=<span class="string">"120px"</span>      v-model=<span class="string">"filterObject"</span>    &gt;&lt;/HHform&gt;  &lt;/div&gt;&lt;/template&gt;<span class="symbol">&lt;script&gt;</span>import HHform from <span class="string">'@/components/HH-form'</span>export default &#123;  name: <span class="string">'Home'</span>,  component<span class="variable">s:</span> &#123;    HHform,  &#125;,  data() &#123;    <span class="keyword">return</span> &#123;      searchOption<span class="variable">s:</span> [        &#123;          <span class="built_in">type</span>: <span class="string">'select'</span>,          prop: <span class="string">'status'</span>,          labe<span class="variable">l:</span> <span class="string">'状态：'</span>,          span: <span class="number">5</span>,          placeholder: <span class="string">'请选择'</span>,          arr: [            &#123;              value: <span class="string">''</span>,              labe<span class="variable">l:</span> <span class="string">'全部招生顾问'</span>,            &#125;,            &#123;              value: <span class="number">1</span>,              labe<span class="variable">l:</span> <span class="string">'正常招顾'</span>,            &#125;,            &#123;              value: <span class="number">2</span>,              labe<span class="variable">l:</span> <span class="string">'冻结招顾'</span>,            &#125;,          ],        &#125;,        &#123;          <span class="built_in">type</span>: <span class="string">'select'</span>,          prop: <span class="string">'region'</span>,          labe<span class="variable">l:</span> <span class="string">'地区：'</span>,          span: <span class="number">5</span>,          placeholder: <span class="string">'请选择'</span>,          arr: [],        &#125;,        &#123;          <span class="built_in">type</span>: <span class="string">'text'</span>,          prop: <span class="string">'userName'</span>,          span: <span class="number">8</span>,          labe<span class="variable">l:</span> <span class="string">'招生顾问名称：'</span>,          placeholder: <span class="string">'选择或输入搜索'</span>,        &#125;,        &#123;          <span class="built_in">type</span>: <span class="string">'text'</span>,          prop: <span class="string">'phone'</span>,          labe<span class="variable">l:</span> <span class="string">'手机号：'</span>,          span: <span class="number">5</span>,          placeholder: <span class="string">'选择或输入搜索'</span>,        &#125;,      ],      filterObjec<span class="variable">t:</span> &#123;&#125;,    &#125;  &#125;,  method<span class="variable">s:</span> &#123;&#125;,  &#125;,&#125;&lt;/script&gt;</code></pre><p>父组件的代码比较简单，直接通过v-model传值过去就行了。下面是演示效果。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2806247738c34c798d679ca4ad7c527d~tplv-k3u1fbpfcp-zoom-1.image" alt="gif"></p><p>目前封装form组件的时候是使用这种方法，父组件直接传值的话，不需要子组件提供方法返回值。在封装search组件的时候则是使用子组件暴露方法的方式拿到值的，为什么这么做呢？因为在进行搜索的时候一定会暴露search跟reset方法，这时候带出去就行了。时隔多个月终于是用上的东西，特地记录下来，希望可以帮助正在封装组件的你。喜欢的可以点个赞或者收藏呗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于疫情的原因啊，我猜大多数人都跟我一样，在家里度过，偶尔学习学习。这不，我遇到了&lt;strong&gt;一个如何手动一个v-model&lt;/strong&gt;的问题，由此展开了学习。&lt;br&gt;在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>VScode配置git的路径</title>
    <link href="http://yoursite.com/2020/03/03/VScode%E9%85%8D%E7%BD%AEgit%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/03/03/VScode%E9%85%8D%E7%BD%AEgit%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2020-03-03T01:19:47.000Z</published>
    <updated>2020-03-03T01:19:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近才开始用VScode写代码，因为之前用的都是webstorm的，虽然好用啊但是经常需要激活，而且激活码变得越来越难找的，所以就改用VScode的。</p><a id="more"></a><p>开始进入主题。今天装完插件Gitlens的时候报错了，说找不到git的路径。<br><img src="./bVbD2Sa.png" alt="2020-03-03_111734.png"></p><p>经过十几分钟的百度，终于知道如何配置了git的路径了（前提是你电脑已经安装好了git）。<br>1.打开vs的设置<br><img src="./bVbD2UW.png" alt="2020-03-03_112425.png"></p><p>2.搜索git.path，冰灾setting.json中打开<br><img src="./bVbD2Vb.png" alt="2020-03-03_112509.png"></p><p>3.找到你的git.exe的位置，如图这是我的git.exe的位置，将地址复制。<br><img src="./bVbD2Vd.png" alt="2020-03-03_112600.png"></p><p>4.直接复制在setting.json中<br><img src="./bVbD2Vx.png" alt="2020-03-03_112633.png"></p><p>明显这是个报错，不能用单斜杠，而是用双斜杠。<br><img src="./bVbD2VI.png" alt="2020-03-03_112652.png"></p><p>好了，重启VScode就不会报错了，并且可以使用Gitlens的功能了。希望能帮助大家少踩坑，如果有帮助希望点了赞，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近才开始用VScode写代码，因为之前用的都是webstorm的，虽然好用啊但是经常需要激活，而且激活码变得越来越难找的，所以就改用VScode的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="VScode" scheme="http://yoursite.com/tags/VScode/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Sticky footer布局</title>
    <link href="http://yoursite.com/2019/11/28/Sticky-footer%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/11/28/Sticky-footer%E5%B8%83%E5%B1%80/</id>
    <published>2019-11-28T03:36:47.000Z</published>
    <updated>2019-11-28T03:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近发现公司的在内容较小的时候使用的是js，通过过去body以及内容高度对比，动态设置footer的position的属性来改变footer是否存在与底部。所以最近搜索了很多关于了sticky footer的布局。鉴于国内环境大多文章都是抄袭，很多内容都是没有只给了关键部分，都没有给了完整的配置，所以特地写了这篇文章仅供参考，如果文中有什么不妥的地方，请各位指出，我会尽量快的修改过来。</p><a id="more"></a><h2 id="利用margin-top以及padding-bottom"><a href="#利用margin-top以及padding-bottom" class="headerlink" title="利用margin-top以及padding-bottom"></a>利用margin-top以及padding-bottom</h2><p>这是一个兼容性比较好的方法，我个人也是比较推荐的，在pc以及移动端都有良好的表现。<br>css代码：</p><pre><code class="highlight stylus">&lt;style&gt;<span class="selector-tag">html</span>,<span class="selector-tag">body</span>,<span class="selector-tag">p</span> &#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>;&#125;<span class="selector-class">.clearfix</span>:after &#123;<span class="attribute">display</span>: block;<span class="attribute">content</span>: <span class="string">''</span>;<span class="attribute">height</span>: <span class="number">0</span>;<span class="attribute">visibility</span>: hidden;<span class="attribute">clear</span>: both;&#125;<span class="selector-tag">html</span>,<span class="selector-tag">body</span> &#123;<span class="attribute">height</span>: <span class="number">100%</span>;&#125;<span class="selector-class">.wrapper</span> &#123;<span class="attribute">min-height</span>: <span class="number">100%</span>;*<span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">background</span>: red;&#125;<span class="selector-class">.wrapper</span> <span class="selector-class">.content</span> &#123;<span class="attribute">padding-bottom</span>: <span class="number">100px</span>;&#125;<span class="selector-class">.footer</span> &#123;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">width</span>: <span class="number">100%</span>;<span class="attribute">margin-top</span>: -<span class="number">100px</span>;<span class="attribute">background</span>: hotpink;&#125;&lt;/style&gt;</code></pre><p>html代码：</p><pre><code class="highlight angelscript">&lt;body&gt;&lt;div <span class="keyword">class</span>="<span class="symbol">wrapper</span> <span class="symbol">clearfix</span>"&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">content</span>"&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">footer</span>"&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">body</span>&gt;</code></pre><p>执行效果自行复制代码实践，这个是经过我自己多次测试发现没有问题的。</p><h2 id="利用flex布局实现"><a href="#利用flex布局实现" class="headerlink" title="利用flex布局实现"></a>利用flex布局实现</h2><p>css代码：</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span>html,body,div,p&#123;margin: 0;padding: 0;&#125;html&#123;height: 100%;&#125;body&#123;min-height: 100%;display: flex;<span class="css"><span class="selector-tag">flex-direction</span><span class="selector-pseudo">:column</span>;</span>&#125;<span class="css"><span class="selector-class">.content</span>&#123;</span>flex: 1;&#125;<span class="css"><span class="selector-class">.footer</span>&#123;</span>width: 100%;height: 100px;background: hotpink;&#125;<span class="tag">&lt;/<span class="name">style</span>&gt;</span></code></pre><p>html代码：</p><pre><code class="highlight angelscript">   &lt;body&gt;&lt;div <span class="keyword">class</span>="<span class="symbol">content</span>"&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">footer</span>"&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">body</span>&gt;</code></pre><h2 id="利用position实现"><a href="#利用position实现" class="headerlink" title="利用position实现"></a>利用position实现</h2><p>css代码：</p><pre><code class="highlight yaml"><span class="string">&lt;style&gt;</span><span class="string">html,</span><span class="string">body,</span><span class="string">p</span> <span class="string">&#123;</span><span class="attr">margin:</span> <span class="number">0</span><span class="string">;</span><span class="attr">padding:</span> <span class="number">0</span><span class="string">;</span> <span class="string">&#125;</span><span class="string">html,body&#123;</span><span class="attr">height:</span> <span class="number">100</span><span class="string">%;</span><span class="string">&#125;</span><span class="string">.wrapper&#123;</span><span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span><span class="attr">position:</span> <span class="string">relative;</span><span class="attr">min-height:</span> <span class="number">100</span><span class="string">%;</span><span class="string">*height:</span> <span class="number">100</span><span class="string">%;</span><span class="attr">padding-bottom:</span> <span class="string">100px;</span><span class="attr">box-sizing:</span> <span class="string">border-box;</span><span class="attr">background:</span> <span class="string">red;</span><span class="string">&#125;</span><span class="string">.footer&#123;</span><span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span><span class="attr">height:</span> <span class="string">100px;</span><span class="attr">position:</span> <span class="string">absolute;</span><span class="attr">bottom:</span> <span class="number">0</span><span class="string">;</span><span class="attr">background:</span> <span class="string">hotpink;</span><span class="string">&#125;</span><span class="string">&lt;/style&gt;</span></code></pre><p>html代码：</p><pre><code class="highlight angelscript">&lt;body&gt;&lt;div <span class="keyword">class</span>="<span class="symbol">wrapper</span>"&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">content</span>"&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;<span class="symbol">p</span>&gt;这是一个<span class="symbol">p</span>标签&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;<span class="symbol">div</span> <span class="symbol">class</span>="<span class="symbol">footer</span>"&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">div</span>&gt;&lt;/<span class="symbol">body</span>&gt;</code></pre><p>同样的，这里通过<strong>padding-bottom为底部留足空间</strong>，<strong>box-sizing：border-box</strong>是为了不让padding计算在内容里。</p><p>暂时只更新这么多，待我测试一下其他的方法，觉得可行之后，再更新出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现公司的在内容较小的时候使用的是js，通过过去body以及内容高度对比，动态设置footer的position的属性来改变footer是否存在与底部。所以最近搜索了很多关于了sticky footer的布局。鉴于国内环境大多文章都是抄袭，很多内容都是没有只给了关键部分，都没有给了完整的配置，所以特地写了这篇文章仅供参考，如果文中有什么不妥的地方，请各位指出，我会尽量快的修改过来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>如何通过git上传代码到github</title>
    <link href="http://yoursite.com/2019/09/10/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github/"/>
    <id>http://yoursite.com/2019/09/10/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github/</id>
    <published>2019-09-10T03:26:20.000Z</published>
    <updated>2019-09-10T03:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在学习mpvue的时候遇到了一些小问题（课程是慕课网上的Sam老师的一门课，非常推荐。）由于不知道老师什么时候回复我，而且为了方便起见，所以就想通过github代码管理来实现（其实之前是用过的，不过就随便用了一下，所以忘记了。）</p><a id="more"></a><p>期间确实遇到不少坑，也比较让我抓狂。（坑会后面单独写一篇，因为上传码云的时候也有坑，所以就一起写）牛皮扯完了，那么就开始介绍了。<br>由于是要上传到github，所以我介绍的是比较通用简单的方法，那么开始第一步（<strong>前提是你电脑已经安装了git</strong>）。<br><strong>先查看有没有ssh秘钥生成</strong><br><img src="./20190910112420671.png" alt="ssh"><br>一般来说就是Administrator里找有没有 .ssh这个文件。<strong>没有就是还没生成ssh秘钥。</strong>（<strong>像我自己的电脑用户名是YDW，所以就是在YDW里面看看有没有这个文件</strong>）<br>直接在桌面git bash<br><img src="./20190910113010728.png" alt="在这里插入图片描述"><br>其实哪里git bash都是可以的。输入以下命令</p><pre><code class="highlight excel">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"你的邮箱地址"</span></code></pre><p><img src="./20190910113512447.png" alt="在这里插入图片描述"><br>因为我已经生成过了ssh秘钥，所以这是会提示我是否要覆盖之前的秘钥（肯定不要啦我，不然我又要重新配置了。）<br>然后回到之前的目录里找.<strong>ssh</strong>文件夹。<br><img src=".n/20190910113843525.png" alt="在这里插入图片描述"><br>第一个是私钥，第二个是秘钥。这是打开第二个文件。（我是有EditPlus，但是大家也可以用记事本打开，这是用记事本打开）<br><img src="./20190910114252199.png" alt="不要纠结为什么有这么大的矩形"><br>这里我进行了处理（其实这算是个人隐私了。）<br>接下来打开<a href="https://github.com" target="_blank" rel="noopener">Github</a>官方网址<br><strong>登陆啥的就不说了，直接新建仓库。</strong><br><img src="./2019091011464548.png" alt="新建仓库"><br>接下来就是下面的界面。<br><img src="./20190910115222266.png" alt="仓库创建配置"><br>仓库已经创建完了。因为我们是通过ssh秘钥上传代码的。所以对应的需要在Github设置一下秘钥。<br><img src="./20190910115828779.png" alt="在这里插入图片描述"><br><img src="./20190910120018496.png" alt="在这里插入图片描述"><br><img src="./20190910120253553.png" alt="在这里插入图片描述"><br>然后回到你之前的仓库那里<br><img src="./20190910120456576.png" alt="在这里插入图片描述"><br><img src="./20190910120602384.png" alt="在这里插入图片描述"><br><img src=".n/20190910120719132.png" alt="在这里插入图片描述"><br><strong>这时候就可以准备上传你的项目了。下面打开你自己的项目，然后右键git bash。</strong><br><img src="./20190910141146852.png" alt="在这里插入图片描述"><br><strong>执行命令 git init 初始化仓库</strong><br><img src="./20190910141302161.png" alt="在这里插入图片描述"><br><strong>创建上传地址的命令是</strong></p><pre><code class="highlight dockerfile">git remote <span class="keyword">add</span><span class="bash"> origin git@github.com:architectMymine/test.git</span></code></pre><p><img src="./20190910142042873.png" alt="在这里插入图片描述"><br><strong>ssh地址是上面在git里面的地址，查看当前创建地址的命令是</strong> </p><pre><code class="highlight ebnf"><span class="attribute">git remote -v</span></code></pre><p><strong>把项目放入暂存区命令(后面是有一个小点的)</strong></p><pre><code class="highlight dockerfile">git <span class="keyword">add</span><span class="bash"> .</span></code></pre><p><strong>这时候会有警告，其实就是不用管，就是提醒你这个文件之前没有而已。（一般警告没有那么多，我这里那么多是因为这个webpack是我自己的配置的，而且还有很多忽略文件没有写，所以这里报错特别多。一般来说做项目都是直接用脚手架帮我们自己创建好比较好。</strong><br><img src="./20190910142606889.png" alt="在这里插入图片描述"><br><strong>提交项目命令</strong></p><pre><code class="highlight nginx"><span class="attribute">git</span> commit -m “提交说明”</code></pre><p><strong>说明那里按照我的习惯就是修复bug，就是写修复什么什么bug，或者出现了什么问题没有解决先提交什么什么的。（执行这个命令后也会有少量警告，不用理会。除非是报错）</strong><br><img src="./20190910143534808.png" alt="在这里插入图片描述"><br><strong>这时候我们就可以执行提交命令了。</strong></p><pre><code class="highlight maxima">git <span class="built_in">push</span> <span class="built_in">origin</span> master</code></pre><p><strong>master这是默认的主分支，实际工作中一般会创建很多分支进行测试或者是调试，这里不详细说了。有空会写一篇详细的介绍。</strong><br><img src="./20190910143957279.png" alt="在这里插入图片描述"><br>上面命令行会多了 -u 这是我上传码云的时候，码云那边给的示例代码，具体上传到Github实际上只要我上面的写的命令行就行了。<br>这时候刷新我们之前的Github页面，就会出现有代码了。<br><img src="./20190910144236906.png" alt="在这里插入图片描述"><br>这个项目是我之前写的一个vue的qq音乐，因为之前提供接口的老朋友被腾讯爸爸警告了，所以我就没再维护用了。好了关于如何将代码上传到Github介绍到这里，码云的其实也差不多原理，而且码云在仓库创建好会给一些初始化命令提示，有兴趣的可以去了解一下，或者咨询一下我也行啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习mpvue的时候遇到了一些小问题（课程是慕课网上的Sam老师的一门课，非常推荐。）由于不知道老师什么时候回复我，而且为了方便起见，所以就想通过github代码管理来实现（其实之前是用过的，不过就随便用了一下，所以忘记了。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>vue刷新浏览器重定向到首页（或者某一个页面）</title>
    <link href="http://yoursite.com/2019/04/10/vue%E5%88%B7%E6%96%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E9%A6%96%E9%A1%B5%EF%BC%88%E6%88%96%E8%80%85%E6%9F%90%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%89/"/>
    <id>http://yoursite.com/2019/04/10/vue%E5%88%B7%E6%96%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E9%A6%96%E9%A1%B5%EF%BC%88%E6%88%96%E8%80%85%E6%9F%90%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%89/</id>
    <published>2019-04-10T13:53:32.000Z</published>
    <updated>2019-04-10T13:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近用vue写一个模仿qq音乐的单页面应用，<br>因为看到黄轶老师的例子是浏览器刷新会路由会重新定向到首页的，<br>所以就想应该是跟路由有关系的。</p><a id="more"></a><p>而且我注意到一个细节。就是我在其他的页面刷新的时候，它会先短暂显示首页，再跳到刷新之前的页面，<br>所以是不是可以理解为项目刷新会先经过首页，再到刷新之前的页面。<br>所以，我就在我的App.vue。写了下面的代码</p><pre><code class="highlight stylus"><span class="function"><span class="title">created</span><span class="params">()</span></span>&#123;         <span class="keyword">if</span>(this.<span class="variable">$router</span><span class="selector-class">.path</span> !== <span class="string">'/recommend'</span>)&#123;            this.<span class="variable">$router</span>.replace(<span class="string">'/recommend'</span>)        &#125;    &#125;</code></pre><p>注意这里的recommend是我项目重定向的首页，判断是不是首页，如果不是就用路由的方法replace，代替的意思。<br>换到首页。<br>这里给大家看一下，没做之前的效果。<br><img src="./20190410215128597.gif" alt="vue"><br>改完之后的效果：<br><img src="./20190410215621395.gif" alt="vue"><br>好了，写一个博文记录一下自己的小聪明，希望看到这个博文的你，有所启发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用vue写一个模仿qq音乐的单页面应用，&lt;br&gt;因为看到黄轶老师的例子是浏览器刷新会路由会重新定向到首页的，&lt;br&gt;所以就想应该是跟路由有关系的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Jquery中按钮事件重复绑定导致事件多次触发解决办法</title>
    <link href="http://yoursite.com/2018/09/21/Jquery%E4%B8%AD%E6%8C%89%E9%92%AE%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E7%BB%91%E5%AE%9A%E5%AF%BC%E8%87%B4%E4%BA%8B%E4%BB%B6%E5%A4%9A%E6%AC%A1%E8%A7%A6%E5%8F%91%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/21/Jquery%E4%B8%AD%E6%8C%89%E9%92%AE%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E7%BB%91%E5%AE%9A%E5%AF%BC%E8%87%B4%E4%BA%8B%E4%BB%B6%E5%A4%9A%E6%AC%A1%E8%A7%A6%E5%8F%91%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2018-09-21T06:46:00.000Z</published>
    <updated>2018-09-21T06:46:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在用jquery绑定事件的时候，一般来说习惯性都是喜欢绑定匿名事件。比如下面的</p><a id="more"></a><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"dv"</span> <span class="attr">value</span>=<span class="string">"按钮"</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-3.3.1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><span class="javascript">        $(<span class="string">".dv"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">// 第一种</span></span><span class="actionscript">            alert(<span class="string">"Hello World"</span>);</span>        &#125;);<span class="javascript">        $(<span class="string">".dv"</span>).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//第二种</span></span><span class="actionscript">            alert(<span class="string">"Hello World"</span>);</span>        &#125;);<span class="javascript">        $(<span class="string">".dv"</span>).bind(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//第三种</span></span><span class="actionscript">            alert(<span class="string">"Hello World"</span>);</span>        &#125;)    &#125;)<span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></code></pre><p>由于是匿名事件，所以假如你这个事件是放在<strong>一个for循环</strong>里面的话，这样的匿名事件是会重复的叠加叠加上去，<br>之所以会叠加，<strong>是因为是匿名事件，会重复的创建空间给这个匿名事件，所以才会导致叠加，这个问题可以后面解决。</strong></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>如果这个事件的挂载元素是一个动态创建的元素的话，就可以避免这样的事件叠加。就是说用的时候创建出来，不用的时候就删除掉这个元素，明显这样的方法会比较的麻烦，我个人也不推荐使用。</p><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>就是在绑定这个事件之前，我们先解绑之前绑定的事件，这样就可以保证每次操作的时候都是只有一个时间，具体的操作就是，如果用on绑定的事件，你就用off取消绑定，再用on绑定事件。代码如下</p><pre><code class="highlight applescript">$(<span class="string">".dv"</span>).off(<span class="string">"click"</span>).<span class="keyword">on</span><span class="params">(<span class="string">"click"</span>,function <span class="params">()</span> &#123; //第二种</span><span class="params">            alert<span class="params">(<span class="string">"Hello World"</span>)</span>;</span><span class="params">        &#125;)</span>;</code></pre><p>如果你用的是bind绑定的话就用unbind取消绑定，这样就可以避免使用匿名事件的时候事件会重复叠加到挂载元素中。</p><h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><p>就是使用one来绑定事件，这样绑定的事件只会触发一次，但是如果这个事件放在循环里面的话，还是会出现问题，这是我自己遇到过的错误，具体怎么绑定事件，代码如下：</p><pre><code class="highlight arcade">$(<span class="string">".dv"</span>).one(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  alert(<span class="string">"Hello World"</span>);&#125;)</code></pre><p>最后一个办法就是从根本去解决，前面说到之所以会重复绑定到这个事件，是因为匿名函数，所以你可以把这个事件放到外面来，这样在循环的过程中，指针会一直指向这个已经创建的命名函数，不会重复创建空间。具体操作如下：</p><pre><code class="highlight arcade">$(<span class="string">".dv"</span>).on(<span class="string">"click"</span>,btn);              <span class="function"><span class="keyword">function</span> <span class="title">btn</span>(<span class="params"></span>) </span>&#123;           alert(<span class="string">"Hello World"</span>);       &#125;</code></pre><p>可能刚接触的萌新们会问，为什么btn后面不加括号。<strong>这里简单的说，如果加了括号就是调用这个函数的返回值，不加括号才是调用这个函数。只要这么记就没有问题了</strong>。好了，希望能帮助到正在学习开发的你。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用jquery绑定事件的时候，一般来说习惯性都是喜欢绑定匿名事件。比如下面的&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
  </entry>
  
</feed>

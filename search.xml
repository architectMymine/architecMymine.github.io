<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>手动实现一个v-model的不同做法</title>
    <url>/2020/03/08/model/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>由于疫情的原因啊，我猜大多数人都跟我一样，在家里度过，偶尔学习学习。这不，我遇到了<strong>一个如何手动一个v-model</strong>的问题，由此展开了学习。<br>在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：</p>
<a id="more"></a>
<p><code>&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</code><br>实则是等于下面的：<br><code>&lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;name=$event.target.value&quot;&gt;</code><br>也就是说，v-model就是<strong>绑定了一个名为value的props和一个事件input</strong><br>            注意：所以在子组件中可以通过props中定义value接受值，然后通过$emit触发input事件传新值并修改。 </p>
<p>知道了这个知识之后啊，那么我们就开始实现一个自定义的v-model啦<del>~</del></p>
<h2 id="一、最简单的实现方法"><a href="#一、最简单的实现方法" class="headerlink" title="一、最简单的实现方法"></a>一、最简单的实现方法</h2><p>首先是父组件的代码：</p>
<pre><code class="highlight xquery"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span>
<span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span>
<span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xquery">&#123;<span class="built_in">&#123;name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>
<span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span>
<span class="xml">      <span class="comment">&lt;!-- 等同于下面 --&gt;</span></span>
<span class="xml">      <span class="comment">&lt;!-- </span></span><span class="xml"><span class="comment">&lt;son type="text" :value="name" @input="name=子组件传回来的值"&gt; --&gt;</span></span>
<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span>

<span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span>
<span class="xml">import Son from './son'</span>
<span class="xml">export default </span><span class="xquery">&#123;</span>
<span class="xquery"> <span class="built_in"> name</span>: <span class="string">""</span>,</span>
<span class="xquery">  data() &#123;</span>
<span class="xquery">    <span class="keyword">return</span> &#123;</span>
<span class="xquery">       <span class="built_in"> name</span>:<span class="string">'ydw'</span>,</span>
<span class="xquery">    &#125;</span>
<span class="xml">  &#125;,</span>
<span class="xml">  components: </span><span class="xquery">&#123;</span>
<span class="xquery">      Son</span>
<span class="xquery">  &#125;</span>
<span class="xml">&#125;</span>
<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></code></pre>

<p>然后是子组件的代码：</p>
<pre><code class="highlight pgsql">&lt;<span class="keyword">template</span>&gt;
  &lt;div <span class="keyword">class</span>&gt;
      &lt;<span class="keyword">input</span> <span class="keyword">type</span>="text" :<span class="keyword">value</span>="value" @input="$emit('input',$event.target.value)"&gt;
  &lt;/div&gt;
&lt;/<span class="keyword">template</span>&gt;

&lt;script <span class="keyword">type</span>="text/javascript"&gt;
export <span class="keyword">default</span> &#123;
  <span class="type">name</span>: "",
  props:&#123;
      <span class="keyword">value</span>:&#123;
          <span class="keyword">type</span>: String,
          defalut () 
              <span class="keyword">return</span> <span class="string">''</span>
          &#125;
      &#125;
  &#125;,
  data() &#123;
    <span class="keyword">return</span> &#123;

    &#125;
  &#125;,
  components: &#123;
  &#125;
&#125;
&lt;/script&gt;</code></pre>
<p>父组件中我加了一个注释的代码行，其实是帮助我自己理解的，不知道有没有小伙伴跟我一样，第一次看的时候压根不知道它在做什么的？哭唧唧。</p>
<h2 id="二、使用watch和-emit实现"><a href="#二、使用watch和-emit实现" class="headerlink" title="二、使用watch和$emit实现"></a>二、使用watch和$emit实现</h2><p>跟上面的一个有些类似，只不过上面是用本身input事件的作用，通过input事件的频发触发传递值给父组件，这里只是将这个过程换成了通过watch监听值得变化，然后通过input事件触发函数事件，函数事件里提交变化的值给父组件。好了，我只需要修改子组件，如下：</p>
<pre><code class="highlight kotlin">&lt;template&gt;
  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>
    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script type=<span class="string">"text/javascript"</span>&gt;
export <span class="keyword">default</span> &#123;
  name: <span class="string">""</span>,
  props: &#123;
    value: &#123;
      type: String,
      defalut() &#123;
        <span class="keyword">return</span> <span class="string">""</span>;
      &#125;
    &#125;
  &#125;,
  <span class="keyword">data</span>() &#123;
    <span class="keyword">return</span> &#123;
      sonVal:<span class="keyword">this</span>.value
    &#125;;
  &#125;,
  watch: &#123;
    value(newval) &#123;
      <span class="keyword">this</span>.sonVal = newval
    &#125;
  &#125;,
  methods:&#123;
    handleModel(e)&#123;
        <span class="keyword">this</span>.sonVal = e.target.value
        <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,<span class="keyword">this</span>.sonVal)
    &#125;
  &#125;
&#125;;
&lt;/script&gt;</code></pre>
<p>通过watch监听props值得变化，赋值给子组件本身定义的sonVal，绑定在input里。然后利用input事件触发函数，提交到父组件。</p>
<h2 id="三、使用最新的语法，model属性。"><a href="#三、使用最新的语法，model属性。" class="headerlink" title="三、使用最新的语法，model属性。"></a>三、使用最新的语法，model属性。</h2><p>本来我是不知道有这个属性的，就是在网上搜索关于v-model实现方法的时候，就不知不觉的查到这个属性，查看官方文档如下：<br><img src="./model.png" alt="avatar"></p>
<p>也就是说这个属性是为了回避props定义的value这个名字的。</p>
<p>下面看看它的用法，我们先看子组件怎么修改：</p>
<pre><code class="highlight xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>
  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>&gt;</span>
    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"val"</span> @<span class="attr">input</span>=<span class="string">"$emit('change',$event.target.value)"</span> /&gt;</span>
  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>
<span class="tag">&lt;/<span class="name">template</span>&gt;</span>

<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span>
<span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span>
<span class="actionscript">  name: <span class="string">""</span>,</span>
  model:&#123;
<span class="actionscript">    prop:<span class="string">'val'</span>,</span>
<span class="actionscript">    event:<span class="string">'change'</span></span>
  &#125;,
  props: &#123;
    val: &#123;
<span class="javascript">      type: <span class="built_in">String</span>,</span>
      defalut() &#123;
<span class="actionscript">        <span class="keyword">return</span> <span class="string">""</span>;</span>
      &#125;
    &#125;
  &#125;,
  data() &#123;
<span class="actionscript">    <span class="keyword">return</span> &#123;</span>
    &#125;;
  &#125;
&#125;;
<span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>
<p>model属性中prop是重新命名传值的名字，而event则是重新命名事件的名字，但是同样的，props中的传值名字必须与model属性中的prop的名字一样。其实只要对比一下第一种方法就知道，vue多出一个model属性是为了value这个名字可以使用。</p>
<h3 id="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"><a href="#同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件" class="headerlink" title="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"></a>同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件</h3><pre><code class="highlight kotlin">&lt;template&gt;
  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>
    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script type=<span class="string">"text/javascript"</span>&gt;
export <span class="keyword">default</span> &#123;
  name: <span class="string">""</span>,
  model:&#123;
    prop:<span class="string">'val'</span>,
    event:<span class="string">'change'</span>
  &#125;,
  props: &#123;
    <span class="keyword">val</span>: &#123;
      type: String,
      defalut() &#123;
        <span class="keyword">return</span> <span class="string">""</span>;
      &#125;
    &#125;
  &#125;,
  <span class="keyword">data</span>() &#123;
    <span class="keyword">return</span> &#123;
      sonVal:<span class="keyword">this</span>.<span class="keyword">val</span>
    &#125;;
  &#125;,
  watch: &#123;
    value(newval) &#123;
      <span class="keyword">this</span>.sonVal = newval
    &#125;
  &#125;,
  methods:&#123;
    handleModel(e)&#123;
        <span class="keyword">this</span>.sonVal = e.target.value
        <span class="keyword">this</span>.$emit(<span class="string">'change'</span>,<span class="keyword">this</span>.sonVal)
    &#125;
  &#125;
&#125;;
&lt;/script&gt;</code></pre>

<p>其实也没多大的修改，只是想贴出来而已。那么手写一个v-model我就写完了，觉得有用的同志给我点个赞赞赞赞赞赞呗。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>this的全面解析</title>
    <url>/2020/05/26/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%BA%8C)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>建议改成：this的全面解析(一)</title>
    <url>/2020/03/12/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%B8%80)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>
article p{
    font-size:16px;
    line-height:28px;
}
</style>


<p>嗨，大家好！过了那么几天我又开始写文章了，这次给大家带来的是this的全面解析。会不会有人会问，怎么突然就这么高产了？其实是这样的，因为这次疫情的出现，让我原本的计划出现了变动，当然也让我认清了我小公司的老板是多么的抠门。所以接下来的文章，基本都是会写一些面试多次会考的问题。当然，作为前端工程师，那么我们的基本功除了HTML，CSS意外，最重要的就是这个JS中的this。废话说完，那么接下来我们就开始了。</p>
<a id="more"></a>

<h2 id="1">this是指向的是谁？</h2>
在多数的情况下，this指向的是调用方法的那个对象。**简单的说就是谁调用函数，那么this就是指向这个对象。**
 <pre><code class="highlight delphi"><span class="keyword">var</span> a = <span class="number">1</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span>
<span class="function"><span class="comment">    console.log(this.a)</span></span>
<span class="function"><span class="comment">&#125;</span></span>
<span class="function"><span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出 1</span></span>
<span class="function"></span>
<span class="function"><span class="title">let</span> <span class="title">obj</span> = <span class="comment">&#123;</span></span>
<span class="function"><span class="comment">    a: 2,</span></span>
<span class="function"><span class="comment">    foo:foo</span></span>
<span class="function"><span class="comment">&#125;</span></span>
<span class="function"></span>
<span class="function"><span class="title">obj</span>.<span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出2</span></span></code></pre>

<p>上面的代码对于老手来说应该没有什么问题。这里我对新手提点注意的点，那就是foo()的调用其实相当于window.foo()，又因为var定义的变量在<strong>非严格模式下</strong>会自动挂载到全局对象中，<strong>在浏览器中，指向 window；在 Node 中，指向 Global。（严格模式下，指向 undefined）</strong></p>
<h2 id="2">this的作用域指向哪里？</h2>
其实在上面的例子中多少可以看出一点苗头，但是呢,为了更加符合面试常见的考题，我打算以下面的代码为例子：

<pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">"zhangsan"</span>;

<span class="keyword">var</span> obj = &#123;

    name:<span class="string">"RadiomM"</span>,

    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; 

        <span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) &#125;;

        x();

    &#125;

&#125;

obj.fn() <span class="comment">// zhangsan</span></code></pre>
<p>是不是答案有点出乎了意料，这是为什么了呢？其实这就是作用域的指向问题，当然关键点还是如何确定this的作用域指向。先说结论：<strong>this的作用域是在调用时指向的，而不是声明指向的。</strong> 我知道，肯定会有很多萌新不明白什么是声明，什么是调用。下面我解析一下。</p>
<h3 id="2.1">声明</h3>
看下面的例子：

<pre><code class="highlight cs"><span class="keyword">var</span> a = <span class="number">1</span>

<span class="function">funciton <span class="title">foo</span>(<span class="params"></span>)</span> &#123;
    console.log(a)
&#125;</code></pre>
<p>没错，就是这么简单，这就是声明。</p>
<h3 id="2.2">调用</h3>
看下面的例子：

<pre><code class="highlight stylus"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span>

funciton foo() &#123;
    console.log(a)
&#125;
<span class="comment">// 这就是调用</span>
<span class="function"><span class="title">foo</span><span class="params">()</span></span></code></pre>

<h3 id="2.3">分析</h3>

<p>你可能以为，哎呀，这x()不是声明在这个对象里面吗？所以你就理所当然的以为，这函数理应输出RadiomM。<br>重要的事情说三遍，建议你大声跟着读下面的字：<br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br>实际上，你读完上面的字，你还是会疑惑，那么为什么输出的就是这个zhangsan呢？其实，我在第一个例子中<br>已经给了提示了，实际上这个x()就相当于window.x()，那么这道题就相当的明了了。</p>
<h2 id="3">总结</h2>
话不多说，直接抬总结上来：

<p>1、this绑定实际上是在函数被调用时发生的绑定，它的指向取决于函数在哪里被调用。</p>
<p>2、this的作用域并不是指向函数的作用域。</p>
<p>其实这篇文章仅仅是入门this的基础，下一篇文章我将会全面解析this的绑定规则。<br>看到这里你可能会问什么会是下一篇呢？因为我写累了啊，哈哈。<br>给大兄弟来首歌轻松轻松。（这篇文章就是在快乐气氛下写完的。学习可别忘了快乐，hasaki！）</p>

    <div id="aplayer-OKzXWgCS" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="29732992" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>

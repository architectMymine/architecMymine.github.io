<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>手动实现一个v-model的不同做法</title>
    <url>/2020/03/08/model/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>由于疫情的原因啊，我猜大多数人都跟我一样，在家里度过，偶尔学习学习。这不，我遇到了<strong>一个如何手动一个v-model</strong>的问题，由此展开了学习。<br>在开始之前我们先需要知道一些知识，v-model是一个语法糖，如下：</p>
<a id="more"></a>
<p><code>&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</code><br>实则是等于下面的：<br><code>&lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;name=$event.target.value&quot;&gt;</code><br>也就是说，v-model就是<strong>绑定了一个名为value的props和一个事件input</strong><br>            注意：所以在子组件中可以通过props中定义value接受值，然后通过$emit触发input事件传新值并修改。 </p>
<p>知道了这个知识之后啊，那么我们就开始实现一个自定义的v-model啦<del>~</del></p>
<h2 id="一、最简单的实现方法"><a href="#一、最简单的实现方法" class="headerlink" title="一、最简单的实现方法"></a>一、最简单的实现方法</h2><p>首先是父组件的代码：</p>
<pre><code class="highlight xquery"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span>
<span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span>
<span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xquery">&#123;<span class="built_in">&#123;name</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>
<span class="xml">      </span><span class="xml"><span class="tag">&lt;<span class="name">son</span> <span class="attr">v-model</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span>
<span class="xml">      <span class="comment">&lt;!-- 等同于下面 --&gt;</span></span>
<span class="xml">      <span class="comment">&lt;!-- </span></span><span class="xml"><span class="comment">&lt;son type="text" :value="name" @input="name=子组件传回来的值"&gt; --&gt;</span></span>
<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span>

<span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span>
<span class="xml">import Son from './son'</span>
<span class="xml">export default </span><span class="xquery">&#123;</span>
<span class="xquery"> <span class="built_in"> name</span>: <span class="string">""</span>,</span>
<span class="xquery">  data() &#123;</span>
<span class="xquery">    <span class="keyword">return</span> &#123;</span>
<span class="xquery">       <span class="built_in"> name</span>:<span class="string">'ydw'</span>,</span>
<span class="xquery">    &#125;</span>
<span class="xml">  &#125;,</span>
<span class="xml">  components: </span><span class="xquery">&#123;</span>
<span class="xquery">      Son</span>
<span class="xquery">  &#125;</span>
<span class="xml">&#125;</span>
<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></code></pre>

<p>然后是子组件的代码：</p>
<pre><code class="highlight pgsql">&lt;<span class="keyword">template</span>&gt;
  &lt;div <span class="keyword">class</span>&gt;
      &lt;<span class="keyword">input</span> <span class="keyword">type</span>="text" :<span class="keyword">value</span>="value" @input="$emit('input',$event.target.value)"&gt;
  &lt;/div&gt;
&lt;/<span class="keyword">template</span>&gt;

&lt;script <span class="keyword">type</span>="text/javascript"&gt;
export <span class="keyword">default</span> &#123;
  <span class="type">name</span>: "",
  props:&#123;
      <span class="keyword">value</span>:&#123;
          <span class="keyword">type</span>: String,
          defalut () 
              <span class="keyword">return</span> <span class="string">''</span>
          &#125;
      &#125;
  &#125;,
  data() &#123;
    <span class="keyword">return</span> &#123;

    &#125;
  &#125;,
  components: &#123;
  &#125;
&#125;
&lt;/script&gt;</code></pre>
<p>父组件中我加了一个注释的代码行，其实是帮助我自己理解的，不知道有没有小伙伴跟我一样，第一次看的时候压根不知道它在做什么的？哭唧唧。</p>
<h2 id="二、使用watch和-emit实现"><a href="#二、使用watch和-emit实现" class="headerlink" title="二、使用watch和$emit实现"></a>二、使用watch和$emit实现</h2><p>跟上面的一个有些类似，只不过上面是用本身input事件的作用，通过input事件的频发触发传递值给父组件，这里只是将这个过程换成了通过watch监听值得变化，然后通过input事件触发函数事件，函数事件里提交变化的值给父组件。好了，我只需要修改子组件，如下：</p>
<pre><code class="highlight kotlin">&lt;template&gt;
  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>
    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script type=<span class="string">"text/javascript"</span>&gt;
export <span class="keyword">default</span> &#123;
  name: <span class="string">""</span>,
  props: &#123;
    value: &#123;
      type: String,
      defalut() &#123;
        <span class="keyword">return</span> <span class="string">""</span>;
      &#125;
    &#125;
  &#125;,
  <span class="keyword">data</span>() &#123;
    <span class="keyword">return</span> &#123;
      sonVal:<span class="keyword">this</span>.value
    &#125;;
  &#125;,
  watch: &#123;
    value(newval) &#123;
      <span class="keyword">this</span>.sonVal = newval
    &#125;
  &#125;,
  methods:&#123;
    handleModel(e)&#123;
        <span class="keyword">this</span>.sonVal = e.target.value
        <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,<span class="keyword">this</span>.sonVal)
    &#125;
  &#125;
&#125;;
&lt;/script&gt;</code></pre>
<p>通过watch监听props值得变化，赋值给子组件本身定义的sonVal，绑定在input里。然后利用input事件触发函数，提交到父组件。</p>
<h2 id="三、使用最新的语法，model属性。"><a href="#三、使用最新的语法，model属性。" class="headerlink" title="三、使用最新的语法，model属性。"></a>三、使用最新的语法，model属性。</h2><p>本来我是不知道有这个属性的，就是在网上搜索关于v-model实现方法的时候，就不知不觉的查到这个属性，查看官方文档如下：<br><img src="./model.png" alt="avatar"></p>
<p>也就是说这个属性是为了回避props定义的value这个名字的。</p>
<p>下面看看它的用法，我们先看子组件怎么修改：</p>
<pre><code class="highlight xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span>
  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>&gt;</span>
    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"val"</span> @<span class="attr">input</span>=<span class="string">"$emit('change',$event.target.value)"</span> /&gt;</span>
  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>
<span class="tag">&lt;/<span class="name">template</span>&gt;</span>

<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span>
<span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span>
<span class="actionscript">  name: <span class="string">""</span>,</span>
  model:&#123;
<span class="actionscript">    prop:<span class="string">'val'</span>,</span>
<span class="actionscript">    event:<span class="string">'change'</span></span>
  &#125;,
  props: &#123;
    val: &#123;
<span class="javascript">      type: <span class="built_in">String</span>,</span>
      defalut() &#123;
<span class="actionscript">        <span class="keyword">return</span> <span class="string">""</span>;</span>
      &#125;
    &#125;
  &#125;,
  data() &#123;
<span class="actionscript">    <span class="keyword">return</span> &#123;</span>
    &#125;;
  &#125;
&#125;;
<span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>
<p>model属性中prop是重新命名传值的名字，而event则是重新命名事件的名字，但是同样的，props中的传值名字必须与model属性中的prop的名字一样。其实只要对比一下第一种方法就知道，vue多出一个model属性是为了value这个名字可以使用。</p>
<h3 id="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"><a href="#同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件" class="headerlink" title="同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件"></a>同样的，这里也贴出使用新属性后，在使用wacth是什么样的，也是只是修改了son组件</h3><pre><code class="highlight kotlin">&lt;template&gt;
  &lt;div <span class="class"><span class="keyword">class</span>&gt;</span>
    &lt;input type=<span class="string">"text"</span> :value=<span class="string">"sonVal"</span> <span class="meta">@input</span>=<span class="string">"handleModel"</span> /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script type=<span class="string">"text/javascript"</span>&gt;
export <span class="keyword">default</span> &#123;
  name: <span class="string">""</span>,
  model:&#123;
    prop:<span class="string">'val'</span>,
    event:<span class="string">'change'</span>
  &#125;,
  props: &#123;
    <span class="keyword">val</span>: &#123;
      type: String,
      defalut() &#123;
        <span class="keyword">return</span> <span class="string">""</span>;
      &#125;
    &#125;
  &#125;,
  <span class="keyword">data</span>() &#123;
    <span class="keyword">return</span> &#123;
      sonVal:<span class="keyword">this</span>.<span class="keyword">val</span>
    &#125;;
  &#125;,
  watch: &#123;
    value(newval) &#123;
      <span class="keyword">this</span>.sonVal = newval
    &#125;
  &#125;,
  methods:&#123;
    handleModel(e)&#123;
        <span class="keyword">this</span>.sonVal = e.target.value
        <span class="keyword">this</span>.$emit(<span class="string">'change'</span>,<span class="keyword">this</span>.sonVal)
    &#125;
  &#125;
&#125;;
&lt;/script&gt;</code></pre>

<p>其实也没多大的修改，只是想贴出来而已。那么手写一个v-model我就写完了，觉得有用的同志给我点个赞赞赞赞赞赞呗。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>this的全面解析</title>
    <url>/2020/05/26/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/17/hello-world/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="需要密码的哦，想看的话打个赏吧." /><label>需要密码的哦，想看的话打个赏吧.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="8340c4627392b94d6ba2ff4a7286a82f4bf879d9e85774a1e73f36507843a925">cc28f03b0de821071abc97c1fa76e5d80f07f4c2af4a2002525ff99a891cdaa6482dd8dfc115e025050012e25404fe78ecfcf01d3f4fea692e3ebcc7fb61ca480ef8abb9f1e10c7c9317f6a5ec2496f180fcc2f9a9774daec0e504ffcf0388ced802603db292263c3091aaa47316dbfb58761e10cb55c7d98e0307cb8a09c42ed5926a129a8688ffdde39310485aabb79644b20057398266246fb277713d2754dee0dad3eec68d024bfc08185153e9acb1a41ce1690b09227ae466211b58cdf603021e09daceea3ce124f149f3d3fb6cd81c7761cf0e1e58c099afa75a4de3ea6ca8badbae866bf87569f4c8b498f628590393f568c4c4dda8650646ca964f3116f77cc59d39dea876b68be9db7ec1215ac4231227166e3fd4bb4576bf34d00583a4180c583bd637fa8e5c8996bf59d00b2ddce0962e83fb65c49ebced15c8cbd5fcfca2761893bf5182666e697eda9d016163c6c0d68007eca0f904e99107d50fa5be7775441b486ea05783f444925418424345279fecb8db124d31e9181004c613b003728bb9148150133b38a4be25b26f646942e075555b8c6a9c9138e0a19f18257e1b115306f7a1a0b6490939ec695b68aae553782ef06a8543a00caf7ff2cada3d8ccb23d7fd039a18a0cbca026a56414eba8905b4027bafd9110a87112e3333026434a4f0a300dd8401c755264b7f4b6e60f4066760fa7ea6420ce484d244c99e2a2928b29c3a1d6917380f594c5d349dece8059eabf681503c244ed3857f750dfd7a45cdf613118769a9258abd11499301164e57f8e91d931a2631316f752e90727819b255ba8d087619cdd31873d5a4e8fbe55db92f1da23eb524beb3143eb16c2f72bbff72bd247fa96c6e479d25381b9a83a0a98dd4af94c46702e150693199751475d56a94e24e70a694575c0fb115e2957f5d91e11a0912f0cb344affa3e795e7a43d586f154f5810aafb44b24ff67c3888b2b8a6f55efd62a57b8656c1d7487dad803b86c083d60354568493353c1bf01962890138be243b785095552f0e7ed9f0b10aa1b5fe8a520d265f57b46fab947ee28e584eb2aca7c47085f2ccfd76ae99c18ea0c063a6654c2a764b02a306713ab66039196610d36ebe4b3bf47a36af42d3fb903e07c5146ef05f03115ae9d8800383c0a552b8e86c7107b56cafab1fba644bba22bf39c98a3263362d33b8b31e0759c2461d9e2981544d18791d9c7ead53dd5070276dcbcaec21f73fc8f7e57ed6678d9f1a4366405b4ee188c58a637c5a7d4601be3d72cb8ab6f9fda925f068a0120d585bd3418883762003bbded5002fdc4e72c37958e8a4652af7270557aaa5dc54e6fed661531f6610e6285363f60a5a79964f05d6e79bd34718e475829b03f2b3522fd1a57925ac6410326e02155be143c5b7da57509d2187258358ee1eea2ebf7f40d739d6eb411d0a01ad0b1507be66cf0e1064849ff057718c6af21955438437e1ffdab510cab52afc92b1443c655f1210c04735f33e8b516bab186b58e32d4d0b1cf42ea46a5f8ac7364ef076aa84abd31cdb4ba9e8bb92c2be7c74f079c759c7ae922bec4d9de1cce76d8cef7a90a985e04f41e74553581749a57b6d14f7f8978c00fee4cc2aee3d95ab8022ef0d683147d51f1bf9162749224c0b977c7fe67eded1a56db994da1967c619c2a2984ecac71d33e92346a0a14ad48c3774e7c5770c0bf14447386bacb15ec053e860f9f6c430059c13d49ae1318ec874bf0e7c6bf4295a5db5d3bc4bf8303e8963805c81fde426b98b1a3a3a976529082b7c1d12e69cfaa20f2f3c95b044b6525ba3e3bbcbe9376d275e83bb488a56d22575032879031cb276507cc9bb86d5174e6bbeb035637acb2076ad6d4733a1cc3765b6bc7a77a2ea91bb8183ffe2a718d2ce19f5fc1aee3dde53c307a785e17d411ab49660efec08e9340c7c3be1f3f5ee17b2e4fa3e7dfab967456c6d0309e0e9a9993e7347e7164fbf8eb419c6902fbb9487d0ef68e1c79fd277af2fb1e7a8547015acb2de31c19e5ff95b5a5cc8443a8f2b94f1a3633f500ce1882b183bd73c872097ea0e6c4e92c181a2ea442a44925b848f73109e2e3409b8104965ae11c87b1270c7ec72286456f3452d3ed21637c533ee7099e9de9ecbc79062e31eca228afc3235a220e932f9988e8cde771db263601b9c0c3ba89c5b8b7eef5111948fc055a4713fc49b88cd17907bb66a61446d706d6f27ac6e96f3ed6a7cef5deb3985882044c194b3b473bfe930e99a7995cf620cecc985d7064ffe5f5ed9b8fdcae93cd52439e862bc0f17954211d3eb31e4ac760e7e188cde12a3da41c5479979b45146baa589b5b45895479645ff77fc9c8ed95a957bb6bee52ba146f678b61206f635949d9bb0b28bee3030d6b28a13162be6ea0cdda6ea33b21ac6c35b17524e564ebd9d1ab1cfef9ec38a10e522fc4b82b1651b521e744c9444ea623b4a4d501a8a432b1d43caa9e4bc184a67e49ee808fca1a30f73f6a17317cd4b40c576f6f8d12c24cba3c40015d412b6087c20b1c80653173f82a6d2edfb33373138c386f7b42a35bc55054bb209ca15f242bca798bd235ca30ee5f14ebc94a2f690ef80d7c2adab0a072d4077324a8e8ee826e68a959fb859f81aff82a4b48c5139293f9011e436489ed227d68eaaeefd44056caf2926ebe51c5bfdbb20d58816e3ca6d66831eb12a79c28b7d255562d260339642214323fab838c414e4200f40d430cddd2a9e67a37cb681fb5c949695a9e652374fcea7c80e9995be42dd07708f3fe5ad98cbe8f42b0d75d07cfcbf15656fbcad671d776db4cb7306aabeec71de2476c60a9b1310cf31962cff0394ae97cd300cd49dc2742877c57baf6489c4577404aa257059e232571adca4b997cd3568f006b72d1bc4c7c9c2747a808e0c5a390b163776beec48971b45efd6bcbb3fafd4510e481a0869ec0fccb0e12684f9dc380770a58f2cccd92806a69d0725f589b2e2b3173b59404da4d0c85fa12fb521169dce8569a5</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>qqq</tag>
      </tags>
  </entry>
  <entry>
    <title>建议改成：this的全面解析(一)</title>
    <url>/2020/03/12/this%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90(%E4%B8%80)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>
article p{
    font-size:16px;
    line-height:28px;
}
</style>


<p>嗨，大家好！过了那么几天我又开始写文章了，这次给大家带来的是this的全面解析。会不会有人会问，怎么突然就这么高产了？其实是这样的，因为这次疫情的出现，让我原本的计划出现了变动，当然也让我认清了我小公司的老板是多么的抠门。所以接下来的文章，基本都是会写一些面试多次会考的问题。当然，作为前端工程师，那么我们的基本功除了HTML，CSS意外，最重要的就是这个JS中的this。废话说完，那么接下来我们就开始了。</p>
<h2 id="1">this是指向的是谁？</h2>
在多数的情况下，this指向的是调用方法的那个对象。**简单的说就是谁调用函数，那么this就是指向这个对象。**
 <pre><code class="highlight delphi"><span class="keyword">var</span> a = <span class="number">1</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span>
<span class="function"><span class="comment">    console.log(this.a)</span></span>
<span class="function"><span class="comment">&#125;</span></span>
<span class="function"><span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出 1</span></span>
<span class="function"></span>
<span class="function"><span class="title">let</span> <span class="title">obj</span> = <span class="comment">&#123;</span></span>
<span class="function"><span class="comment">    a: 2,</span></span>
<span class="function"><span class="comment">    foo:foo</span></span>
<span class="function"><span class="comment">&#125;</span></span>
<span class="function"></span>
<span class="function"><span class="title">obj</span>.<span class="title">foo</span><span class="params">()</span> <span class="comment">// 输出2</span></span></code></pre>

<p>上面的代码对于老手来说应该没有什么问题。这里我对新手提点注意的点，那就是foo()的调用其实相当于window.foo()，又因为var定义的变量在<strong>非严格模式下</strong>会自动挂载到全局对象中，<strong>在浏览器中，指向 window；在 Node 中，指向 Global。（严格模式下，指向 undefined）</strong></p>
<h2 id="2">this的作用域指向哪里？</h2>
其实在上面的例子中多少可以看出一点苗头，但是呢,为了更加符合面试常见的考题，我打算以下面的代码为例子：

<pre><code class="highlight javascript"><span class="keyword">var</span> name = <span class="string">"zhangsan"</span>;

<span class="keyword">var</span> obj = &#123;

    name:<span class="string">"RadiomM"</span>,

    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; 

        <span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) &#125;;

        x();

    &#125;

&#125;

obj.fn() <span class="comment">// zhangsan</span></code></pre>
<p>是不是答案有点出乎了意料，这是为什么了呢？其实这就是作用域的指向问题，当然关键点还是如何确定this的作用域指向。先说结论：<strong>this的作用域是在调用时指向的，而不是声明指向的。</strong> 我知道，肯定会有很多萌新不明白什么是声明，什么是调用。下面我解析一下。</p>
<h3 id="2.1">声明</h3>
看下面的例子：

<pre><code class="highlight cs"><span class="keyword">var</span> a = <span class="number">1</span>

<span class="function">funciton <span class="title">foo</span>(<span class="params"></span>)</span> &#123;
    console.log(a)
&#125;</code></pre>
<p>没错，就是这么简单，这就是声明。</p>
<h3 id="2.2">调用</h3>
看下面的例子：

<pre><code class="highlight stylus"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">1</span>

funciton foo() &#123;
    console.log(a)
&#125;
<span class="comment">// 这就是调用</span>
<span class="function"><span class="title">foo</span><span class="params">()</span></span></code></pre>

<h3 id="2.3">分析</h3>

<p>你可能以为，哎呀，这x()不是声明在这个对象里面吗？所以你就理所当然的以为，这函数理应输出RadiomM。<br>重要的事情说三遍，建议你大声跟着读下面的字：<br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br><strong>this的作用域是在调用时指向的，而不是声明指向的！！！！！</strong><br>实际上，你读完上面的字，你还是会疑惑，那么为什么输出的就是这个zhangsan呢？其实，我在第一个例子中<br>已经给了提示了，实际上这个x()就相当于window.x()，那么这道题就相当的明了了。</p>
<h2 id="3">总结</h2>
话不多说，直接抬总结上来：

<p>1、this绑定实际上是在函数被调用时发生的绑定，它的指向取决于函数在哪里被调用。</p>
<p>2、this的作用域并不是指向函数的作用域。</p>
<p>其实这篇文章仅仅是入门this的基础，下一篇文章我将会全面解析this的绑定规则。<br>看到这里你可能会问什么会是下一篇呢？因为我写累了啊，哈哈。<br>给大兄弟来首歌轻松轻松。（这篇文章就是在快乐气氛下写完的。学习可别忘了快乐，hasaki！）</p>

    <div id="aplayer-yYoYCnsw" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="29732992" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
